# 런타임 데이터 영역

<img width="593" height="488" alt="image" src="https://github.com/user-attachments/assets/7a7ab7ed-912d-4262-a24c-00dc7e4296c1" />

## 프로그램 카운터(pc)
- 실행중인 스레드의 바이트 코드 줄 번호 표시기
- 스레드 프라이빗 메모리 영역에 존재
- 스레드가 네이티브 메서드를 실행중일때 프로그램 카운터 값은 Undefined

## 자바 가상 머신 스택
- 스레드 프라이빗 메모리
- 스택 ㅂ프레임에 지역변수 테이블, 핑녀산자 스택, 동적 링크, 메서드 반환값등의 정보를 저장
- 지역변수 테이블의 슬롯은 일반적으로 32비트, 따라서 64비트 데이터의경우는 두칸 차지
- 설정에 따라 더 늘수있음
- 스택오버플로우, ooe 발생 가능

## 네이티브 메서드 스택
- 네이티브 메서드 사용시
- 구현레벨이 정해져있지않아서 여러 구현체가 다 다르게 구현됨 os따라 다를듯

## 자바 힙
- 객체 인스턴스를 저장하는 역할, 모든 인스턴스와 배열은 힙에 할당됨
- 다만 모든은 아니고 거의 모든임 예외가 존재함
- GC가 활동하는 장소이며, GC는 이 힙을 세대별로 구분해서 동작, 힙자체는 그러한 스펙은 없음

## 메서드 영역
- 모든 스레드가 공유
- 타입 정보, 상수, 정적변수, JIT 컴파일러가 컴파일한 코드 캐시등을 저장, 논힙영역
- 과거엔 힙의 영구영역, 현재는 네이티브 영역의 메타스페이스

## 런타임 상수풀
- 메서드 영역의 일부
- 클래스 버전, 필드, 메서드, 인터페이스 등 클래스 파일에 포함되 ㄴ설명 정보에 더해 컴파일 타임에 생성된 다양한 리터럴과 심벌 참조가 저장

### String intern()
- 해당 문자열값이 스트링풀에 있으면 그 참조를 반환하고 없으면 pool에 추가한 뒤 그 참조를 반환
- 즉 직접 new String("something") 한뒤 해당 객체에 intern을 호출하면 실제 상수풀에 있는 경우 해당 상수로 참조가 바뀜
<img width="754" height="687" alt="image" src="https://github.com/user-attachments/assets/59469825-3f97-4a9f-8133-10a7a2c3f553" />
 
- 해시코드는 오버라이드되어 문자열기준이라 그런듯

## 다이렉트 메모리
- NIO에서 사용하는 네이티브 메모리
- 컨테이너환경에서 메모리 할당시 특히 누락되기쉬움 해당 메모리도 고려할것
- 특별히 미지정하면 dm max를 xmx와 동일한 값으로 취급, 미리 커밋치는게 아니라 malloc하는거라 처음엔 oom안남

### 컨테이너 메모리 설계 팁
Container Memory
≥ 
Xmx
+ MaxDirectMemory
+ Metaspace
+ ThreadStack
+ Native 여유분

# 가상머신과 객체

## 객체 생성과정
1. jvm이 new 명령 바이트코드를 읽음
2. 매개 변수가 상수 풀 안의 클래스를 가리키는 심벌참조인지 확인
3. 심벌참조에 해당하는 클래스가 로딩, 해석, 초기화되었는지 확인
4. 준비되지않은 클래스라면 로딩부터~
5. 새 객체를 담을 메모리를 할당
6. 객체의 헤더에 필요한 정보를 기입 - 클래스의 인스턴스인지, 메타정보는 어떻게찾느지, 해시코든느 무엇인지 등등
7. 현재 상황는 객체 헤더 + 모든 필드 기본값 0, 아직 init() 메서드는 호출되지 않음

<img width="551" height="233" alt="image" src="https://github.com/user-attachments/assets/494bf1e0-bc0b-47ad-9296-725e8befa6d0" />

- new 이후 INVOKESPECIAL 이 호출될때 init() 이 실행됨

### 문제점 1 : 힙은 단조증가하지 않음
- gc의 불규칙한 객체 삭제때문에 파편화되기 쉽고 따라서 메모리할당시 단조증가하는 포인터보다는 충분한 공간을 찾아 할당후 목록갱신하는식
- 다만 여기서도 gc의 compact행위가 가능하냐에따라 다른 알고리즘을 채택할수도있음
- gc동작에따라 크게 달라진다


### 문제점 2 : 동시성문제
- 여러 스레드가 여러 객체를 할당시도시 발생할수있는 동시성문제로 메모리 할당시 포인터 경합

#### 1차접근 CAS
- 낙관락방식인 CAS 접근으로 시도

#### 2차 동기화
- 실패시 원자적 수행으로 동기화

### +@ TLAB
 - 스레드별 로컬 할당 버퍼가 있어서 포인터가 겹치는일이 최소화, 그만큼 compact는 못하지않나?


## 객체의 메모리 레이아웃

<img width="801" height="426" alt="image" src="https://github.com/user-attachments/assets/cefc4623-a47c-493d-9d2f-1ee241cd5a70" />

### compressed oop

https://xephysis.tistory.com/6

### 객체 헤더
- 32비트 가상머신에선 32비트, 64비트에선 64비트 크기
- 객체 해시코드, 객체 세대 나이, 락 플래그
- klass word의 객체의 클래스 관련 메타데이터를 가리키는 포인터
- 배열이라면 배열 길이도 여기에

### 인스턴스 데이터
- 객체가 실제로 담고있는 정보
- 필드관련 내용, 부모클래스유무, 부모클래스에서 정의한 필드 등등

### 정렬 패딩
- 자동 메모리 관리시스템상 객체의 시작주소가 반드시 8바이트 정수배여야하므로 패딩으로 채움

## 객체에 접근하기
- handle이나 다이렉트 포인터를 사용해 jvm은 객체에 접근함
- 핸들의 경우 스택 지역변수 -> 힙내에 핸들풀 -> 실제 데이터
- 핸들풀의 핸들 포인터를 통해 실제 데이터가 이동시에도 스택 지역변수를 건드릴일은 없어짐
- 다이렉트 포인터 방식이라면 실제 주소가 스택 참조에 바로 저장
- 핫스팟은 주로 다이렉트 포인터방식을 사용하지만 일부 gc에따라 추가적인 포워딩을 하게되는경우도있음



