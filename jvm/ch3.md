# GC를 공부해야하는 이유
- 다양한 메모리 오버플로와 누수문제를 해결해야하는 상황
- 더 높은 동시성을 달성하는데 GC가 방해가 되는 상황
- 적절히 모니터링하고 조율할수 있어야하기떄문

# 죽은 객체 판단
## 참조 카운팅 알고리즘
- 객체를 가리키는 참조 카운터를 추가, 참조하는곳이 늘어날때마다 ++
- 참조하는곳이 하나 사라질때마다 카운터 값을 1씩 감소
- 카운터 값이 0이 된 객체는 더는 사용할 수 없음

- CPython은 O, 자바는 X
- 순환차조 문제 풀기 어려움 : 단둘이 서로 참조하고있다면 사실상 두 객체는 쓸모없는 객체들이지만 아무튼 참조 카운터 1

## 도달 가능성 분석 알고리즘
- GC루트라고 하는 루트 객체들을 시작 노드로 삼고 시작노드부터 DFS로 도달 못하는 객체만 삭제
### GC루트 대상
- 가상머신 스택에서 참조하는 객체 : 실행중인 메서드에서 쓰인 매개변수, 지역변수, 임시변수 등
- 메서드 영역에서 클래스가 정적 필드로 참조하는 객체 : 자바 클래스의 참조 타입 정적 변수
- 메서드 영역에서 상수로 참조되는 객체 : 문자열 테이블 안의 참조
- JNI가 참조
- jvm 내부에서 쓰이는 참조
- syncronized로 잠겨있는 객체
- 자바 가상 머신 내부 상황을 반영하는 JMXBean

## 참조 개념
- 강한 참조 : 전통적인 정의의 참조. 프로그램 코드에서 참조를 할당
- 소프트 참조 : 유용하지만 필수는 아닌 객체. 캐싱캐념. 메모리 오버플로가 나기 직전에 2티어 회수에서 회수될 대상으로 SoftReference클래스
- 약한 참조 : 소프트 참조보다 낮은 티어의 참조로 다음번 GC까지만 사는 대상. WeakReference 클래스
- 파이널 참조 : finalize 호출시 대기열큐에 들어가는 경우. 해당 큐에서 참조는 하고있으니 아무튼 참조
- 팬텀 참조 : 대상 객체가 회수될때 알림을 받기위한 용도로 사실상 참조로 취급안함. PhantomReference 클래스

## 실제 죽었는지 살았는지 판단 과정
- 알고리즘으로 도발 불가능판단이 되면 1차 마킹
- 마킹된 객체들은 finalize 호출 대상인지 필터링 - 이미 호출했는지
- F큐라는 대기열에 추가
- 대기열 큐 내에서 만약 다시 참조가 되면 부활
- 부활한 경우에도 다시 도달 불가능 판단되면 이때는 finalize호출 없이 바로 삭제

> 즉 finalize는 객체 삭제라기보단 삭제 대기열에 추가이며 일종의 사형선고같은 개념. 살아나도 다시 도달불가능이 되면 그냥 강제 삭제됨.

```java
package com.jvm;

class FinalizeEscapeGC {
  public static FinalizeEscapeGC SaveHook = null;

  public void isAlive() {
    System.out.println("살아있음");
  }

  @Override
  protected void finalize() throws Throwable {
    super.finalize();
    System.out.println("삭제중");
    SaveHook = this;
  }

  public static void main(String[] args) throws InterruptedException {
    SaveHook = new FinalizeEscapeGC();

    SaveHook = null;
    System.gc();
    Thread.sleep(500);
    if (SaveHook != null) {
      SaveHook.isAlive();
    } else {
      System.out.println("주금 ㅠ");
    }

    SaveHook = null;
    System.gc();
    Thread.sleep(500);
    if (SaveHook != null) {
      SaveHook.isAlive();
    } else {
      System.out.println("주금 ㅠ");
    }

  }
}
```

<img width="376" height="117" alt="image" src="https://github.com/user-attachments/assets/2ee2926d-9db4-4ebc-a997-d1d2237cd07e" />

unreachable 2번 되면 finalize는 더 호출되지 않고 바로 삭제


## 메서드 영역
- 상수와 클래스가 회수 대상
  - 이 클래스으 ㅣ인스턴스가 모두 회수됨
  - 이 클래스를 읽어 들인 클래스 로더가 회수됨
  - 이 클래스에 대핟ㅇ하는 java.lang.Class 객체를 아무곳에서도 참조하지 않고 리플렉션기능으로 이 클래스의 메서드를 이용한느곳도 전혀 없음


# GC 알고리즘

## 세대 단위 컬렉션 이론
### 객체 생존주기 경험칙
- 약한 세대 가설 : 대다수 객체는 일찍 죽는다
- 강한 세대 가설 : GC 과정에서 살아남은 횟수가 늘어날수록 더 오래 살 가능성이 커진다
- 세대 간 참조 가설 : 세대간 참조의 개수는 같은 세대 안에서으 ㅣ참조보다 훨씬 적다

### 힙 영역 구분
- 세대단위 컬렉션 이론을 적용한 JVM(GC)는 힙영역을 Old, Young 최소 두가지 이상으로 구분

#### CMS gc기준
- 실제 물리적으로 메모리 레인지가 있어서 Young(eden, survivor 0, 1) Old로 완전히 다른영역
  - GC마다 그럼 메모리 물리적이동을 위한 복사이동GC가 일어난단소리
#### G1Gc
- 힙을 고정크기 region으로 쪼개고 gc가 돌면 그 지역의 세대 자체를 변경
- 이후 남은 객체들을 한곳으로 모아 단편화 방지 - 결국 객체 이동은 발생함
- 힙의 지역별 세대를 기록하는 별도 메타데이터 영역이 존재

### GC 동작 구분
- 마이너 GC : 신세대만 대상으로 하는 GC
- 메이저 GC : 구세대만 대상으로 하는 GC
- 혼합 GC : G1 컬렉터 특유 동작으로 신세대 + 구세대 일부
- 전체 GC : 메서드영역까지 몽땅 GC

## 동작 알고리즘
### 마크 스윕 알고리즘
- 마킹하고 한번에 제거
- 실행효율이 일정하지 않음
- 메모리 파편화가 심함

### 마크 카피 알고리즘
- 가용메모리를 절반으로 나누고 한쪽만쓰다가 gc시점에 생존 객체를 반대편에 싹 새로 쌓기전략
- 최신gc들은 young 세대에 한해 해당 알고리즘을 응용해 사용

#### 아펠스타일 GC - 마크 카피 응용
- 신세대를 하나의큰 에덴공간과 두개의 작은 서바이버 공간으로 분리 Young(eden, survivor 0, 1)
- eden과 0에 객체를 쌓다가 gc후 1로 모두 이동
- 이후 다시 eden과 1에 객체를 쌓다가 gc 후 생존 객체는 0으로 이동
- 위를 반복하며 eden, o, 1 은 각각 8:1:1 비율이므로 실제로는 10%의 메모리만 낭비하는셈
- gc카운터가 일정회수 이상도달하면 해당 객체는 old로
- 여기도 결국 STW는 일어남 아주 짧을뿐

## 마크 컴팩트 알고리즘
- 구세대는 오래사는 객체들이므로 마크카피 아펠스타일시 복사가 너무 많이일어나서 문제
- 마킹후 생존객체를 앞에서부터 쭉 쌓고 이후 남은 지점을 모조리 삭제
- old 영역을 대상으로 하므로 객체 이동은 애플리케이션을 멈춘 상태에서 진행하므로 STW

### 파편화 vs 조각모음
- STW를 해야하지만 파편화를 극복하려면 연결리스트로 객체를 메모리할당해야하는데 이경우 메모리 할당과 접근 효율이 떨어지게됨
- 객체 전체를 읽는건 같아서 시간복잡도가 동일하게 n일텐데 왜 접근 효율이 떨어지지?
- 하드웨어적인문제로 cpu의 prefetcher 등의 동작으로 인해 순차적으로 어디서부터 어디까지 읽을떄가 물리적 지연이 제일 적고 대역폭을 최대로 활용가능함
- 데이터의 접근, 사용 패턴상 GC보다는 메모리에 객체 할당 및 조회가 압도적으로 많으므로 조각모음방식을 선택하는것이 합리적

# 핫스팟 알고리즘 상세

## 루트 노드 열거

- GC 루트 집합에서 참조 체인을 잡는 작업
- 참조 체인을 어떻게 효율적으로 구현할까
- 루트 노드 열거 단계에서는 STW는 필수
- oopMap을 사용해 좀더 효율적으로 루트 노드를 열거

### OopMap
- 특정 시점에 스택 / 레지스터 슬롯에 객체 참조가 있다는걸 JVM이 알고있게 해주는 자료구조로 GGC가 루트를 추측하지 않고 즉시 열거할 수 있음
- 즉 현 시점에서 static하게 root가 되는 대상 이외의 런타임 root 노드객체들만 따로 모아두는 곳

## 안전지점
- GC가 수시로 도는게 아니라 안전지점으로 정해진 구간에만 동작
- 세팅값으로 조절 가능
- 안전지점의 위치 선택 기준은 프로그램이 장시간 실행될 가능성이 있는가
- 안전지점 멈추는 방법은 크게 두가지
  - 선제적 멈춤 : 시스템이 모든 사용자 스레드를 인터럽트, 현실적으로 없음
  - 자발적 멈춤 : 간단한 플래그 비트를 두고 스레드가 폴링하면서 비트값 true시 안전지점으로 멈춤

## 안전 지역
- 스레드가 잠자기나 블록된 상태일경우 해당 스레드의 컨텍스트는 자발적 안전지점으로 멈출수 없으므로 코드 영역내에서 안전지역이란 개념이 별도로 존재
- 해당 스레드가 멈춰있을때에도 안전지역이라면 ok 하지만 안전지역이 아닌곳이라면 활성화까지 기다려야함

## 세대간 객체 참조 문제 해결 : 기억집합과 카드 테이블

 - 기억집합 : 비회수 영역에서 회수 영역을 가리키는 포인터들을 기록하는 추상 데이터 구조
### 기억 집합 구현 방법
- 워드 정밀도 방식 : 레코드 하나가 메모리의 워드 하나에 매핑, 해당 워드가 세대간 포인터
- 객체 정밀도 방식 : 레코드 하나가 객체 하나에 매핑, 틀정 레코드가 마킹되어있다면 해당 객체에 다른 세대의 객체를 참조하는 필드가 있다는 뜻
- 카드 정밀도 방식 : 레코드 하나가 메모리 블록 하나에 매핑, 틀정 레코드가 마킹되어있다면, 해당 블록에 세대간 참조를 지닌 객체가 존재
- 세번째 방식으로 구현한것이 카드 테이블

## 메모리 장벽
- 장벽 지점 전후의 메모리 접근 순서를 CPU, 컴파일러가 절대 바꾸지 못하게 강제하는 규칙

```
int a = 1;
int b = 2;
int c = a + 5;  // a에 의존
int d = b + 3;  // b에 의존
```

```
; 최적화된 어셈블리 코드
mov eax, 1      ; a = 1
mov ebx, 2      ; b = 2
add ebx, 3      ; d = b + 3 (먼저 계산)
add eax, 5      ; c = a + 5 (나중에 계산)
```


[cs 메모리 장벽 4가지 유형](https://codediary21.tistory.com/166)

- 동시성문제인 소비사 생산자 문제에서 각 장벽이 발생할수 있는 동시성문제에대한 일부 보장을 해준다고 이해하면 됨


### volatile
- 캐시 없이 즉시 메모리 변경 및 조회를 강제하여 읽기 가시성을 강제
- 읽고 수정후 삽입이므로 원자적 read and write은 아니며 쓰기 동시성문제를 해결하지는 못함

### 읽기 장벽
- 현대의 CPU나 컴파일러는 최적화를 통해 명령어 실행순서가 바뀔수 있는데 이러한 동시 비순차 실행 문제를 해결하기위한 기술
- 해당 값을 읽기 전에 필요한 메모리상태를 먼저 정합화
- 캐시된 오래된 값을 읽지 않도록하는 가시성 보장
- 순서보장

### 쓰기 장벽
- aop처럼 쓰기 행위시 데코레이팅 동작 추가

# 가비지 컬렉터의 종류들 특성 파악하기

## 클래식 가비지 컬렉터

### 시리얼
- 단일 스레드 컬렉터
- STW

### 파뉴
- 시리얼 컬렉터 병렬버전

### CMS 동시 마크 스왑 GC

- 구세대 GC중 가장 유명
- 123차 마크단계와 사용자 스레드와 함께 GC가 일어나는 동작을 보장
- 마크 단계에서만 stw가 일어나기때문에 다른 구세대 gc에 비해 일시정지 자체가 적음
- 그만큼 스레드를 일부 점유하기때문에 처리량의 감소는 존재
- 당연한 얘기지만 리소스는 한정되어있고 주기적으로 올스탑후 지연이 발생하더라도 gc냐 처리량 일부를 소비하ㅕ gc냐의 동작차이이며 이는 애플리케이션의 행동패턴에따라 적합도가 다름
- 동시실행 처리량이 적고 응답속도가 빨라야한다면 CMS, 처리량 자체가 중요하며 일정 지연이 괜찮다면 기존방식일것
- 일반적인 웹서비스(cms) vs 야간배치 정산,ETL, 로그집계 등 (처리량gc) => online 이냐 offline이냐로 구분하자
- jdk 14에서 제거

## G1 컬렉터(가비지 우선)
- 사실상 서버용 기본 모드
- gc회수대상을 지역으로 잘게 쪼갬으로서 gc 작동시 stw를 s 이하로 아주 짧게 멈추도록 설계, 기본값은 200ms? - 책이 뭔가 이상한데?
- g1gc는 cms처럼 동시삭제는 못함
- 리전 절반보다 큰 객체만을 위한 큰 객체 영역도 존재
- 결국은 maxPuase를 낮춰서 stw를 짧고 자주 하는논리긴한데 훨씬 계획적으로 특히 old gc를 섞어서 자주 함으로써 더 계획적이고 full gc가 오는상황을 최대한 방지
- 가장 효율적인 지역을 gc타겟으로 삼음
- 메모리 회수 속도가 메모리 할당 속도를 따라가지 못한다면 G1 도 full gc 가능
- 최초 표시, 재표시, 복사 청소시에 사용자 스레드는 STW됨, MS이 아니므로 사용자스레드와 동시에 실행은 불가능



# 저지연 최신 GC
> gc 삼각 정리 : 처리량, 지연시간, 메모리 사용량

하지만 메모리는 결국 하드웨어 발전으로 싸지므로 처리량과 지연시간 모두를 잡는 방식으로 발전해야함

이논리면 CMS가 나은거 아닌가? 메모리사용량 파편화하다가 정리하는식으로...

- 위의 정리처럼 cms는 지연문제는 적지만 처리량의 감소, g1gc는 지연문제를 피할수 없음
- 차기 gc인 셰넌도어, zgc는 동시 마킹, 동시 모으기를 지원하는걸 목표로함
  - 결국 stw 를 10ms 이하 고정으로 목표

## 섀낸도어
- 오라클이 관리하지않는 오픈소스 gc
- 객체 헤더에 간접 포인터를 넣어 사용자 스레드가 동작하는 도중에도 특정 영역의 객체 삭제 및 compact 시 이동이 가능하게됨
  - 기존 g1gc는 세대간, 지역간 참조객체들때문에 일부 지역만 객체를 제거하고 남은 객체를 이동할때도 stw가 필요했으나 간접포인터를 사용함으로서 동시수행이 가능
  - 하지만 그만큼 메모리사용량이 10%이상 크고, 간접포인터를 사용하는데에  따른 오버헤드로 처리량이 많이 떨어짐
  - 아직 개발


## zgc
- jdk15 부터 탑재
- 21부터는 세대구분 가능
- 동시 마크 컴팩트 알고리즘을 구현하기 위해 읽기장벽, 컬러 포인터, 메모리 다중 매핑 기술을 사용

### 동적 리전기반

### 병렬 모으기와 컬ㄹ러 포인터
- 아키텍처적으로 64비트 cpu는 한번에 주소연산을 64비트 기준으로 사용하므로 포인터가 64비트를 쪼개서 실제 주소값과 검증값으로 사용
- jvm에서 검증영역인 빈공간을 활용해 포인터 자체에 flag를 심음

## 엡실론 컬렉터
- 동작하지 않는 gc
- gc가 필요없는 환경, 일시적으로 실행하는 앱등에 적합


# GC 선택하기

## 컬렉터간 비교 및 취사선택

### 핵심 요인 3가지

#### 어플리케이션의 주목적
- 데이터 분석, 계산등 처리량이 중요한 케이스?
- SLA 애플리케이션으로서 서비스 품질이 중요?
- 임베디드 시스템?

#### 애플리케이션을 구동하는 서브시스템은 무엇인가
- 아키텍처, os, cpu와 메모리

#### 사용하는 jdk 제공자와 버전

## 오라클 가이드

- 100mb, 단일프로세서만 사용하고 일시정지 제약이 없다면 -> 시리얼 컬렉터
- 애플리케이션 최대성능중요하고 지연이 허용된다면 -> 패러럴
- 처리량보다 응답시간이 중요하고 가비지 컬렉션에 따른 일시정지가 짧아야한다면 -> g1
- 응답시간이 매우 중요 -> zgc


# 메모리할당과 회수

## 객체는 먼저 에덴에 할당

```java
class FinalizeEscapeGC {
  private static final int _1MB = 1024 * 1024;

  public static void main(String[] args) {
    byte[] allocation1, allocation2, allocation3, allocation4;
    allocation1 = new byte[2 * _1MB];
    allocation2 = new byte[2 * _1MB];
    allocation3 = new byte[2 * _1MB];
    allocation4 = new byte[4 * _1MB];
  }
}
```

<img width="1132" height="492" alt="image" src="https://github.com/user-attachments/assets/e25cb92b-9fc1-4a82-a642-8db4bb4aa555" />

- 힙이 20mb이므로 young이 그절반인 10mb 그리고 8:1:1 비율이므로 8mb가 eden
- 객체할당이 6mb 되고 4mb 할당 불가능하므로 에덴의 8mb를 old로 이동, 이후 할당하여 4mb 사용, tenure에 6+@가 있는걸 확인 가능


## 큰 객체는 바로 old로

```java

class FinalizeEscapeGC {
  private static final int _1MB = 1024 * 1024;

  public static void main(String[] args) {
    byte[] allocation1, allocation2, allocation3, allocation4;
    allocation1 = new byte[2 * _1MB];
    allocation2 = new byte[2 * _1MB];
    allocation3 = new byte[2 * _1MB];
    allocation4 = new byte[10 * _1MB];
  }
}
```

<img width="1301" height="500" alt="image" src="https://github.com/user-attachments/assets/d57eaea7-d95c-42f5-bc1a-ef1e44ff8149" />

- 큰 4번째 객체가 바로 tenure로














