# JVM

- 자바 가상머신
- 자바 바이트 코드를 OS에 특화된 코드로 변환(인터프리터와 JIT 컴파일러)하고, 메모리에 올려 실행하는 역할
- 자바가 플랫폼 독립적으로 실행할수 있게 해주는 핵심 가상머신
- jvm자체는 플랫폼에 종속적, os에 맞춰서 코드를 변환해야하니까
- 스펙이 있고 벤더사가 구현하는 개념

## JVM 구조

### 클래스 로더 시스템
- 자바바이트 코드를 읽어 적절하게 메모리에 배치하는 역할

#### 종류
- 부트 스트랩 클래스 로더
  - JAVA_HOME/lib 에 있는 코어 자바 API를 제공한다. 최상위 우선순위를 가진 클래스 로더
  - 네이티브라 사용자 정의 클래스로더로부터 접근 불가능하고 모든 클래스 로더의 최상위 부모
- 플랫폼 클래스 로더
  - JAVA_HOME/lib/ext 폴더 또는 java.ext.dirs 시스템 변수에 해당하는 위치에 있는 클래스를 읽는다
  - 확장 라이브러리들을 로드하는 역할
  - 부트스트랩 클래스로더가 로드하지 않는 클래스들
- 애플리케이션 클래스 로더
   - 애플리케이션 클래스 패스에서 클래스를 읽는다
   - 일반적인 패키지패쓰의 클래스들은 이 클래스로더가 읽어온다
  

#### 1. 로딩
- 클래스를 읽어오는 과정
- 클래스 로더가 .class 파일을 읽고 그 내용ㅇ에 따라 적절한 바이너리 데이터를 만들고 메서드 영역에 저장
- 이때 메서드 영역에 저장하는 데이터는
  - Full Qualified Class Name
  - 클래스 | 인터페이스 | 이늄
  - 메서드와 변수
- 로딩이 끝나면 해당 클래스 타입의 Class객체를 생성해서 힙 영역에 저장(Class객체는 결국 힙에 있는것!)

#### 2. 링크
- 레퍼런스를 연결하는 과정
- (1) verify : 검증
- (2) prepare : 메모리를 준비하는 과정
- (3) resolve(Optional) : 심볼릭 메모리 레퍼런스(논리적인 레퍼런스)를 메모리 영역에 있는 실제 레퍼런스(힙에 있는 실제)로 교체


#### 3. 초기화
- static 값들 초기화 및 변수에 할당

### 실행엔진
#### 인터프리터
- 바이트 코드를 한줄씩 실행하는 역할

#### JIT 컴파일러
- 인터프리터 효율을 돕기 위해 인터프리터가 반복되는 코드를 발견하면 JIT 컴파일러에 보내고 이를 모두 네이티브 코드로 바꿔두어 보다 최적화 하는 용도의 실시간 컴파일러

#### GC
- 쓰이지 않는 객체를 찾아서 제거하는 역할
- 커스터마이징을 해야할필요가 있음
- 쓰로풋 위주 vs 스탑더월드를 줄이는 스타일
- 많은 객체를 생성하고 응답시간이 중요하다면 STW를 줄이는 스타일 선택하기 vs 처리량이 많고 최대한 CPU를 애플리케이션 실행에 투자하고싶을경우 쓰로풋 위주의 GC를 선택


### 메모리 영역
#### 스택
- 런타임 스택
- 메서드 콜을 스택프레임으로서 쌓음
#### PC
- 쓰레드마다 쓰레드 내 현재 실행할 스택 프레임을 가리키는 포인터
#### 네이티브 메서드 스택
- 네이티브 메서드 사용할때 별도로 쌓이는 스택
- JNI
- 네이티브 메서드 라이브러리
#### 힙
- 객체들
#### 메서드
- 클래스 이름, 부모클래스 이름, 메서드명, 스태틱 변수들 등등 공유자원으로서 로드됨

# JRE
- 최소 배포 단위
- JVM + Library(default)
- 자바 애플리케이션을 실행할수 있는 최소 단위
- 개발하는데 필요한 툴은 제공 X
- 자바 컴파일러도 안들어있다!, 런타임에 필요한게 아니니까
- 이제는 JRE는 배포 없음 ㅠ

# JDK
- JRE + 개발툴

