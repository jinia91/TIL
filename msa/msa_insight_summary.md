# 모놀리식
## 장점
- 개발이 간단
- 애플리케이션 변경이 쉬움
- 테스트가 쉬움
- 배포가 쉬움
- 확장이 쉬움
## 단점
- 최초엔 개발이 간단할지라도 성공한 앱은 비즈니스에 대한 요구사항 달성을 위해 끊임없이 배대해져가고, 결국 너무 복잡해진 앱은 개발자를 압박함
- 비대해진 앱은 실행속도도 느리고, 코드를 고치고 빌드/실행후 테스트하기까지 너무 많은 시간이 낭비되어 생산성을 떨어뜨리는 요인이 됨
- 최근트랜드는 지속적인 배포(CD`continuos Deployment`)로 기민한 배포를 통해 그만큼 빠른 유저경험 개선을 달성함
  - 2011 아마존은 11.6초마다 한번씩 배포가 일어났고, 2019 국내 aws 컨퍼런스의 발표내용에 따르면 현재 아마존 서비스의 배포주기는 초당 1.5!
  - 하지만 모놀리틱 구조에서는 스프린트를 거쳐 feature 브랜치로 기능개발을 여러팀들이 병럴적으로 이루어냈더라도 코드를 merge하는시점, 사이드이펙트 고려, qa실시등 오버헤드가 발생
- 서버 특징에 따라 확장이 어려움
  - 이미지 처리 모듈과같은 고연산을 요하는 비즈니스 로직을 처리하려면 cpu 코어수가 많은 서버에 배포하는것이 최적일것이며, 대용량 데이터를 빠르게 처리하기위해 인메모리 내부 캐시를 사용하는 특정 모듈은 메모리가 큰 서버에 배포하는것이 최적.
  - 하지만 모놀리식구조에서는 이를 특화시키기어려움
- 점점 비대해질수록 신뢰성하락, 결함격리가 되지않고 모듈하나에 버그가 있어도 전체 애플리케이션이 다운되는 일도 발생할 가능성이 있음
- 사이드이펙트때문에 버전업이 어렵고 새로운 기술에 보수적일수밖에없어 갈수록 오래된 기술스택이 발목을 잡음

# 소프트 아키텍쳐와 빠른 기능 개발
- 빠른 기능개발과 아키텍쳐와는 사실 큰 상관이없음
- 어떤 아키텍쳐도 어떤 기능을 개발하는데 무관
- 하지만 애플리케이션의 특성과 아키텍쳐는 긴밀한 연관관계가 있음
- maintainablity, testablity, extensibility(scalability ..,.)
- 모놀리식은 결국 언젠가는 진흙더미 스파게티 코드지옥으로 빠질수밖에없다. 
  - 조직 규모가 커지고 그 큰 규모의 조직이 하나의 흙덩이를 만지는일은 결국 누군가가 컨벤션을 어기게됨


# 마이크로서비스는 뭐지?
> bounded context가 있는 느슨한 coupling의 elements 서비스 지향 아키텍쳐 - adrian cockcroft
## 확장 큐브 - 애플리케이션이 커지는 방향성에 대한 분석
### x 축 확장 - scale out 분산확장
로드밸런싱과 여러 서버를 통한 분산
### z축 확장 
특정 인스턴스가 라우터에 의해 특정 요청만 수행하도록 하는 확장방식(샤딩혹은 replication과 range별 접근같은 개념)
### y축 확장 - 기능에 따라 애플리케이션을 서비스로 분해
X축과 Z축 확장의 결합
서비스별로 분해된 모듈은 트래픽양에 따라 개별적으로 x축 확장을 하며, 필요에 따라 고가용 데이터군 트래픽을 분산키위해 z축 확장도 실시

> 각서비스가 집중/응집된 책임을 갖고 모듈성을 갖게하는게 핵심! 모놀리식방식의 패키지 모듈분리는 한계가 명확, 무엇보다 느슨한 coupling 달성이 힘듬
> 하지만 msa는 api라는 경계를 통해 명확한 분리과 느슨한 coupling이 달성

## msa 장점
- 크고 복잡한 애플리케이션을 지속적으로 전달/ 배포가능
- 서비스규모가 작아 관리하기 쉬워짐
- 서비스를 독립적으로 배포 / 확장이 가능
- 분리된 서비스덕분에 팀이 작은단위로 쪼개져 더 자율적이고 민첩하게 움직일수 있음! - conway's law
- 결함 격리가 잘됨
- 다양한 기술스택을 폴리글랏을 통해 통합 가능

## msa 단점
- 서비스를 뜯어내는 기준이 모호, 레퍼런스 컨벤션의 부족 아키텍트의 역량에 의존
- 분산시스템이 복잡하여 테스트가 어렵고 러닝커브가 높아짐
- 결국 중앙집권적 서비스가 존재하게되면 같은 문제를 또 겪게됨(결함격리, SPOF)
- 도입시기 결정이 어려움

## MSA 아키텍처를 구축할때 고려할 내용을 패턴으로 살펴보면
### MSA로 분해하는 패턴? 두가지
- 비즈니스능력에 따라 분해
- DDD관점에서 분해
### 서비스간 통신 패턴은?
- 통신스타일은? 어떤 IPC사용?
- 디스커버리: 서비스 인스턴스의 IP주소는 어떻게 찾지?
- 신뢰성: 서비스 불능시 통신 신뢰성은? circuit breaker
- 트랜잭셔널 메시징 : 메시징 기반 EDA
- 외부 api와 연동 : api gateway
### 트랜잭션 관리를 위한 데이터 일관성 패턴
- 분산트랜잭션은 x, 최근엔 saga pattern에따라 일관성 유지(eventually consitency)
- eda, event sourcing

### 데이터 쿼리 패턴
여러 서비스에 흩어진(여러 디비에 흩어진) 데이터를 조회하는 패턴
- composition pattern
- CQRS pattern

### 배포 패턴
- 컨테이너 배포
- 서버리스방식

### 모니터링 패턴
- 헬스체크 api
- log aggregation
- 분산 추적
- 예외 추적
- metrics
- audit logging

ELK 스택

### 테스트 자동화 패턴
- 느리고 복잡한 종간테스트는 가급적 피하고 서비스를 따로 분리해서 테스트하는 테스트 단순화 패턴이 필요
- Consumer-driven contract test(클라이언트 의도대로 서비스가 동작하는지 확인)
- Consumer-side contract test(클라이언트와 서비스가 상호통신 가능한지 확인)
- service component test

### 횡단관심 패턴
- 마이크로서비스 섀시 패턴

### 보안 패턴
- api 게이트웨이
- jwt 

### 콘웨이 법칙에 의거, msa가 성공하기 위해서는 작고 기민하며 효율적인 데브옵스, 자율적인소규모 조직이 여러단위로 

  
