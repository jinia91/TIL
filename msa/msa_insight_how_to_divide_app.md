# 소프트웨어 아키텍처

## 정의
소프트웨어 아키텍쳐란 : 구성요소(elements)들이 의존관계(dependency)로 엮인 고수준의 구조물
   - 소프트웨어의 품질속성의 지표들이 정의되며 이를 통해 아키텍쳐 - 소프트웨어의 특징을 쉽게 파악할수있음
   - 과거 소프트웨어는 확장성, 신뢰성, 보안이 핵심 목표였으나, 현재는 신속 / 안전하게 전달하는 능력도 중요


> MSA는 관리성 테스트성 배포성이 높은 애플리케이션을 구축하는 아키텍처 스타일

## 4+1 모델 - Phillip Krutchen

- 논리뷰 : 개발자가 작성한 소프트웨어 엘리먼트, logic. 클래스, 패키지등을 말함
  - E : 클래스 및 패키지
  - Dependency 클래스, 패키지간 관계
- 구현뷰 : 빌드 시스템의 결과물. 모듈과 콤포넌트로 jar 파일같은것
  - E : 모듈 및 컴포넌트
  - 관계 : 모듈/컴포넌트간 관계 
- 프로세스뷰 : 런타임 컴포넌트.
  - E : 프로세스
  - 프로세스간 통신(!)
- 배포뷰 : 프로세스가 머신에 매핑되는 방법
  - E : 머신, 프로세스
  - 관계 : 네트워킹

+ 1 : 시나리오로 뷰를 작동시킴


## 레이어드 아키텍처
- 엘리먼트를 계층별로 구성하는 전형적인 아키텍처 스타일
- 계층마다 명확히 정의된 역할을 분담하며, 계층간 디펜던시는 아키텍처로 제한
- 일반적으로 의존성이 아래 계층으로 향함

### 구성
- 표현, 비지니스, 영속계층들

### 단점

- 비즈니스로직이 영속계층을 의존하는 방향성의 문제
- 이를 해결하기위해 DIP를 통해 인터페이스와 구현을 분리하고 인터페이스를 비즈니스 레이어로 올려 영속계층의 의존성이 비즈니스 레이어를 향하도록할수는 있음
- 하지만 이것은 하위계층이 중간계층인 비즈니스계층을 바라보게되는 구조이며, 레이어드 아키텍처의 본래 정의와 원칙과는 다르다!

## 헥사고날 아키텍처
- DIP로 분리시킨 인터페이스와 구현을 포트와 어댑터로 정의하고 프리젠테이션, 인프라 레이어의 의존방향을 비즈니스 레이어에 향하게 하는 아키텍처
- 헥사고날 가운데에 존재하는 애플리케이션, 엔티티, 도메인은 포트만 정의될 뿐, 어댑터에대한 어떤 의존성을 갖지 않는다.
- 포트는 인바운드/아웃바운드(인고잉, 아웃고잉이 더 이해하기쉬움)로 나뉘며 인바운드는 web, http등의 컨트롤러들이나 메시지 핸들러들, 아웃고잉은 전통적인 infra 기반 혹은 외부서비스들을 예시로듬
- 인고잉시 포트는 서비스인터페이스 혹은 facade

## MSA도 협의의 아키텍처다
- 4+1 기준 구현뷰가 다수의 콤포넌트를 가짐(여러 jar들)
- 각각의 콤포넌트들은 헥사고날 아키텍처로 구성된 작고 견고한 서비스 애플리케이션들
- 프로세스 뷰에서는 이러한 서비스 애플리케이션들이 통신 프로토콜을 통해 연결

> 핵심은 서비스애플리케이션 여러개가 느슨히 결합된, '독립적으로 배포' 가능한 구성!

### 서비스란 그럼 무엇일까?
- 특정 서비스 기능을 수행하기위해 커맨드, 쿼리, 이벤트로 구성된 API
- 커맨드 : CUD
- 쿼리 : R
- 이벤트 : 비즈니스 로직의 결과, 어댑터를 통해 발행
- MSA 관점에서 서비스의 규모 사이즈가 중요한것이 아님

### 그럼 모듈간 코드 중복은 어쩌지?
- 공유 라이브러리
- 여러 애플리케이션에서 재사용 가능한 기능은 라이브러리화 시키기!
- 하지만 의도치 않은 서비스간 결합도 유발은 조심
  - 따라서 변화가능성이 제법 있다면 별도서비스로 구현하는것이 낫지, 라이브러리화할필요는 없다.
  - 바뀔일이 거의 없는 코드들, 예를들어 snowFlake53 방식의 분산환경에서 Id generate한는 전략등은 라이브러리화하는것도 좋음
  - 모놀리스 구조에서 `shared` 로 별도 패키징해놓은 코드들이 이 대상


# 모놀리스 -> 분해해보기

## 개요

1단계 : 유즈케이스 - 기능요건, 시스템 작업 식별
2단계 : 필요한 서비스 식별
3단계 : 서비스 api 및 협동 정의

- 핵심 장애물 : 네트워크 지연, 서비스간 동기 통신으로 인해 가용성이 떨어지는 문제, 데이터 일관성 문제, 만능 클래스들(god object 개념)

## 시스템 작업 식별 

1. 사용자 스토리 - usecase를 식별, 그 동작을 고수준의 도메인 모델 관점에서 기술하기
2. 기술한 내용을 UML로 표현해보기
3. 시스템 작업을 정의하여 input 과 필요한 데이터, output에대해 산정해보기

## 서비스 정의: 비지니스 능력 패턴별 분해

1. 비즈니스 능력은 곧 조직이 하는일, 비즈니스 능력을 식별하기
  - eg) 비즈니스상 최상위 능력 - 하위 능력으로 구분하여 분해하는 개념

2. 비즈니스 능력을 서비스로 매핑하기

> 핵심은 서비스를 산출할때 비즈니스 능력에 따라 구성하는것!

## 서비스 정의: 하위 도메인 패턴별 분해

- 서비스를 정의할때 DDD관점에서 구축
- SRP, CCP(`Common Closure Principle`) 준수
  - CCP : 어떤 두 클래스가 동일한 사유로 변경되면 동일한 패키지에 있어야한다는 것


# 고질적 장애 해결하기 예시

## 네트워크 지연
- 배치 API 구현 (`https://cloud.google.com/data-catalog/docs/http-batch?hl=ko`)

## 동기 IPC로 인한 가용성 저하
- rest 프로토콜은 가용성이 떨어지는 문제가 존재하므로 비동기 메시징으로 강한 결합도를 제거하고 가용성을 높이기

## 여러 서비스에 걸쳐 데이터 일관성 유지
- `saga` 패턴 사용 -> eventual consistency 보장

## 만능 클래스 분해
order 를 예시로 들면, Order 안에 배달이있고, 주문 접수, 과금, 음식점 등이 모두 존재하게끔 도메인이 구성될수도 있는데, 이는 너무 비대한 모델

- 배달 / 주문접수 / 결제를 order 와 분리하여볼수도있다! 주문은 어디까지나 주문만 신경쓰도록

# 추가적인 고민 키워드들

- CQRS로 데이터 레플리카를 가지어 자기 완비형 서비스 만들기
- 비동기 메시징 활용방법으로 사가 패턴과 보상트랜잭션 패턴
- api 게이트웨이, api 조합패턴(단순히 api요청을 서비스로 넘기는것만이 아닌, 이를 조합하는 패턴)



3단계 : 서비스 api 및 협동 정의ㅅㅏ유로 ㅈㅏㅇ애 
3단계 : 서비스 api 및 협동 정의ㅅㅏ유로 
