# Summary

## Intro
- 잘 설계된 객체지향 App은 낮은 결합도, 높은 응집도(`low coupling high cohesion`)
- 객체가 명확하게 한가지 일만 잘 하는 객체인가?(`SRP`)
- `SRP`는 필연적으로 객체간 많은 커뮤니케이션을 유도
- 커뮤니케이션 == 의존성
- 의존성 == 결합도
- 과도한 의존성은 `OCP`를 위배케함(`tight coupling`)
    - 의존성 : 의존하는 요소가 변경될 때 의존하는 요소도 함께 변경될 수 있음을 의미
- 객체지향 설계란 의존성을 관리하는것, 객체가 변화를 받아들일수 있게 의존성을 정리하는 기술!(`lead to loose coupling`)
    - 결국 재사용성과 변경 용이성이 핵심

## 1. 의존성 이해하기

### '의존성' 이란 워딩에 대해 - vs 의존관계

![첨부 이미지](https://jinia-img-bucket.s3.ap-northeast-2.amazonaws.com/03c1237f-668e-48b9-83d0-9a2bbadb3626.png)

[UML에서 말하는 의존 관계]

- 의존성(`Dependency`)는 UML 상의 의존 관계(`Dependency Relationship`)과는 다른 관점/개념
- 의존성은 UML 상의 관계`'Relationship`) 전체를 포괄하는 개념으로 이해



### 간접 의존성과 의존성 전이

>A객체가 B객체를 알고있고, B객체가 C 객체를 알고있다

=> 간단한 3단논법처럼 `A객체는 C객체를 알수'도' 있다.`

의존성이 전파되는 여부는 B객체가 C객체를 얼마나 캡슐화 하느냐에 따라 다름!





### 명시적 의존성과 묵시적 의존성

객체 내부에서 의존하는 객체의 생성주기를 관여하게되면 묵시적 의존성이 생기고, 묵시적 의존성은 결국 의존성 파악을 위해 내부 구현을 확인해야하는 일이 생김!

따라서 묵시적 의존성을 피하고 의존성을 명시하는 코드가 더 좋은코드다!

명시적 의존성을 표현하기 위해서는?

의존성을 주입해주는것이 가장 바람직!

의존성을 주입해주면 내부 구현을 보지 않고도 해당 객체가 어떤 의존성을 가지는지 `Public Interface`를 통해 노출됨

> `sudoController.setterService(new ConcreteService());`

- `sudozController가 ConcreteService를 의존하고있구나! 라고 정확히 파악 가능`


### 위의 논리로 NEW는 해롭다
- `new`를 잘못 사용하면 클래스 사이의 결합도가 극단적으로 높아진다
- `new` 연산자를 사용하면 구체클라스를 노출, 인자도 모두 노출하므로 결합도가 지나치게 높아지게됨



# 유연한 설계

## `OCP`

### 런타임 의존성 컴파일 의존성

> 정적타입언어에서 더 잘 설명되는 개념

#### 런타임 의존성

- 애플리케이션이 실행되는 시점에 생기는 의존성
- 객체간 의존성
 
#### 컴파일 의존성

- 코드 그자체, 코드단위 의존성
- 클래스간 의존성

`Invoker` 와 `Reciever` 두 객체간 커뮤니케이션 상황에서, 다형성을 적용해 `Invoker`가 `Receiver` 추상 클래스를 바라보는 의존성을 만들었다면, 

컴파일 의존성 시점에서는 `Invoker`는 구체적 `Reciever`를 알지 못할 것이다.

하지만 런타임시점에서는 구체적 `Reciever`를 의존관계 주입을 통해 받게 되므로,  `Invoker`와 `Concrete Reciever`간 의존성이 생기게 된다.

### 의존성 해결하기

- 간접의존성은 최소화,
- 컴파일 의존성은 추상적으로
- 구체적 구현체에 대한 의존성은 런타임 시점으로 교체하기(의존성 주입 방법)
    - 객체를 생성하는 시점에 생성자를 통해 의존성 해결
    - 객체 생성 후 setter메서드를 통해 의존성 해결
    - 메서드 실행시 인자를 이용해 의존성 해결

- 스프링 의존성 주입(`DI`) 전략과 동일!

### 추상화가 핵심

## 생성 사용 분리

> 객체의 생성은 어디에서 하는것이 가장 바람직한가? 생성과 사용을 분리(`separating use from creation`)

> 소프트웨어 시스템은 (응용 프로그램 객체를 제작하고 의존성을 서로 연결하는) 시작단계와 (시작 이후에 이어지는) 실행 단계를 분리해야한다 


### Sol 1. 객체의 생성 책임을 클라이언트에게

> A 클라이언트가 context를 갖고 있으며, B객체에게 메시지를 전달할때,  B객체가 C객체의 생성과 사용 책임을 갖고있는경우, C객체의 생성 책임을 A객체에게 주고, B객체에겐 C객체를 인자로 전달하는 방법

### Sol 2. Factory 추가하기
> 만약 A 클라이언트에게 context를 주기 싫다면?

- 객체 생성만 전담하는 Factory 객체를 만들어 해결하기!
- `Factory`는 `Pure Fabrication`
    - 객체지향이 실세계의 모방이라는 말이 틀린이유!
    - 객체지향은 설계자들이 임의적으로 창조한 인공적인 추상화들을 포함하고있고, 오히려 그런 개념이 더 많은 비중을 차지한다.

## 의존성 주입(`DI`)

>사용할 객체 생성 책임을 다른 객체에게 전가한다는것은, 해당 의존성을 외부에서 주입받는다는 것

- 생성자 주입
- setter 주입
- 메서드 주입


## DIP

- `Seperated Interface` 패턴
- 객체를 인터페이스와 구현으로 분리한 후, 인터페이스를 서버 모듈이 들고있는것이 아닌, 클라이언트 모듈이 들고있게하여 의존성 방향을 역전시키는 것



## 유연한 설계는 유연성이 필요할때만 옳다

- 유연한 설계와 단순하고 명료한 설계는 정 반대의 길
- 유연한 설계라는것은 복잡한 설계를 의미
- **정말 유연성이 필요한 부분인가?!**
- 불필요한 유연성은 불필요한 복잡성을 낳는다


> 인간의 지적 능력은 정적인 관계에 더 잘 들어맞고, 시간에 따른 진행과정을 시각화하는 능력은 덜 발달되있다. 이러한 이유로 우리는 정적인 프로그램과 동적인 프로세스 사이의 간극을 줄이기 위해 최선을 다해야하며, 이를 통해 프로그램과 진행과정 사이를 가능한 일치시켜야한다. - Dijkstra




