오브젝트 정리(1~3장)

1장 객체, 설계

소프트웨어 모듈이 가져야하는 세가지 기능 로버트 마틴 클린소프트웨어 애자일 원칙과 패턴, 그리고 실천방법
-1 요구사항을 제대로 구현하는것
-2 모듈은 생명주기동안 반드시 변경되므로(그리스 철학자 헤라이클레이토스는 우주에서 변하지 않는것은 변하지 않는다는 사실뿐) 간단한 작업만으로도 변경이 가능해야함
-3 코드를 읽는 사람과 의사소통하는것(읽는 사람과 의사소통할수 없는 모듈은 잘못된 모듈) - 클린코드 원칙

Step1.




Theater 객체가 모든것을 통제하는 설계

문제점은 크게 2가지

Theater 중심의 절차지향적 설계 - 변경에 취약

uml에서 표현하는 연관관계(실선)로든, 의존관계로든(점선) Theater객체는 많은 다른 객체를 의존하고 있으며, 이는 결합도가 높은 코드로 변경에 취약함

불필요한 의존성이 없는지 검토할 필요가 있음

역할과 책임의 분배가 잘 이루어 졌는가?

Theater가 너무 많은 일을 하고 있음


Theater가 가방에게 초대장을 달라고하는 메시지 전달하는 코드
 if(audience.getBag().hasInvitation())
과연 Theater가 가방에게 초대장을 달라는 메시지를 보낼 책임이 있는가? 등등


+ 디미터 법칙과 자료구조 접근

최종



Theater가 알고있는 의존관계가 줄고 

자신의 데이터를 스스로가 처리하도록 audience, ticketseller에게 책임을 분배하므로서 oop 설계를 실천

불필요한 의존관계가 몇개 줄기는 했지만 전체적인 의존관계의 수로 생각하면 사실 크게 축소된것은 아님

위의 설계와 아래 설계의 차이점은 바로 책임의 이동

절차적 프로그래밍 방식과 객체지향적 프로그래밍 방식의 차이이며

모든 책임이 Theater에 있는 설계와 책임이 분배되있는 설계

결국 설계란 책임의 분배

객체지향 설계란 객체에 책임을 분배하는 것, 더 raw하게는 코드를 분배하는것


클린코드에서는 oop를 신봉할 필요는 없다고 말함 객체지향 설계와 절차지향설계는 모두 장단이 있음

하지만 자바가 객체지향 패러다임을 근간으로 하고 있으며, 디폴트 메서드를 가진 인터페이스등 성숙한 oop 코드 작성에 유리하며, 협업관점에서도 oop적 코드가 강점이 많으므로

객체지향 설계를 지향하는것이 바람직하지 않나싶다

의존성을 효율적으로 통제할수 있는 다양한 방법을 제공하므로써 요구사항 변경에 좀더 수월하게 대응할수 있는 가능성!

객체간의 의존성은 애플리케이션을 수정하기 어렵게 만드는 주범(커플링)

데이터와 데이터에 해당하는 프로세스를 한덩어리로 모으고 객체들 사이의 의존성을 적절하게 조절하는것이 핵심



2장~3장  객체지향 프로그래밍 , 역할 책임 협력

영화 예매 시스템 예제로 설명

2장은 객체지향 프로그래밍을 구성하는 다양한 요소와 구현기법에 대해 코드로 설명함

협력, 객체, 클래스 
객체지향 설계에서 가장 먼저 고려할것은 클래스가 아니라 객체
어떤 객체들이 필요한지 고민할것
객체를 독립적인 존재가 아니라 기능을 구현하기위해 협력하는 공동체의 일원으로 생각할것

객체란 상태와 행동을 함게 가지는 복합적인 존재이며, 행동이 상태를 규정하는 사고방식이 중요하다고 저자는 주장

클래스 작성자와 클라이언트 프로그래머로 구분하기

내가 코드를 작성하는동안은 클래스 작성자이지만, 몇달이 지난후 해당 코드를 보거나, 협업하는 다른 팀원이 해당 코드를 보고 사용하게 될때믄 클라이언트 프로그래머다.

api를 만드는 관점도 똑같음

코드 작성자는 항상 내 코드가 인터페이스로서 클라이언트가 사용할수 있음을 인지하고, 내부의 구현과 인터페이스를 철저히 분리시켜 구현은 감추고, 이해하기 쉬운 인터페이스만 제공하는것이 바람직

인터페이스와 구현이 잘 분리되면, 클라이언트 프로그래머가 알아야할 지식의 양이 줄어들고 클래스 작성자가 자유롭게 구현을 변경할수 있는 폭이 넓어짐


추상클래스 인터페이스를 조합해 다향성을 구현하는 기본적인 방법

할인 정책과 할인 조건 구현에서 구체적인 policy대신 상위 추상화된 인터페이스에 의존하여 다향성 구현

상속의 오버라이딩을 통한 동적인 주입

동적 바인딩, 지연바인딩과 오버라이딩


composition over inheritance

상속보단 합성이 캡슐화 측면에서 더 좋은 방법



3장에서는 객체지향의 구현 기법들보다 중요한 객체지향 설계에서 고려할점


협력이란

1장에서 객체지향 설계는 객체들의 책임을 적절하게 분배하는것이라고 정의

이 책임이라는것은 어디에서 오는가?

요구사항 -> 요구사항을 충족하기위해 필요한 행동 = 어플리케이션의 책임

애플리케이션의 책임이 바로 협력이라는 문맥

이 거대한 책임(협력)을 이루기 위해 필요한 행동들이 바로 객체의 책임


책임이란

Crc 카드 기법

객체의 책임은 크게 하는것과 아는것으로 구분

책임은 해당 책임 행동을 하기에 필요한 정보들을 가진 정보전문가에게 분배되는것이 가장 바람직

따라서 책임을 할당하는데 필요한 메시지를 먼저 식별하고 메시지를 처리할 객체를 선택하자

그리고 메시지를 처리한 객체는 그 메시지에 따라 상태가 결정되게 된다.

책임주도 설계

시스템이 사용자에게 제공해야하는 기능인 시스템책임을 파악
시스템 책임을 더 작은 책임으로 분할
분할된 책임을 수행할수 있는 적절한 객체 또는 역할을 찾아 책임을 할당
객체가 책임을 수행하는 도중 다른 객체의 도움이 필요한 경우 이를 책임질 적절한 객체 또는 역할을 찾기
해당 객체 또는 역할에게 책임을 할당함으로써 두 객체가 협력하게 하기


역할
역할의 개념이 애매했는데 이번에 정리됨

역할은 협력안에서 같은 책임을 수행할수 있는 객체들을 바꿔낄수 있는 슬롯

즉 협력 안에서 객체들간의 의사소통 구조로 표현하지만

이 책임을 수행할 객체가 여려개고 분기로 갈리게 되는 상황이 존재할수 있음

이때 이 책임을 수행할 자리를 객체로 표현하는것이 아닌 역할로 표현하는것

즉 인터페이스, 추상화			



