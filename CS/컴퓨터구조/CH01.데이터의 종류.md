---


---

<h2 id="진법과-진법-변환">진법과 진법 변환</h2>
<ul>
<li>
<p>정보 단위</p>
<ul>
<li>1 nibble = 4 bit</li>
<li>1 byte = 8 bit</li>
<li>1 byte = 1 문자</li>
<li>영어는 1 byte, 한글은 2 byte</li>
<li>1워드 : 특정 cpu에서 취급하는 명령어나 데이터의 길이에 해당하는 비트 수
<ul>
<li>워드 길이는 일반적으로 8의 배수</li>
</ul>
</li>
</ul>
</li>
<li>
<p>알아둬야할 진법</p>
</li>
</ul>

<table>
<thead>
<tr>
<th>16진수</th>
<th>2진수</th>
<th>10진수</th>
<th>8진수</th>
</tr>
</thead>
<tbody>
<tr>
<td>0~9</td>
<td>0000~1001</td>
<td>0~9</td>
<td>0~11</td>
</tr>
<tr>
<td>A~F</td>
<td>1010~1111</td>
<td>~15</td>
<td>12~17</td>
</tr>
<tr>
<td>14</td>
<td>0001 0100</td>
<td>20</td>
<td>24</td>
</tr>
</tbody>
</table><ul>
<li>16진수 8진수는 결국 2진수를 4개단위 2개단위로 잘라 읽기위해 쓰는것</li>
</ul>
<h2 id="보수">보수</h2>
<ul>
<li>
<p>최댓값(해당 bit에서 가장 큰 표현형)을 형성하는데 서로 보완관계에 있는 두수 사이의 관계를  One’s COMPLEMENT 라고함</p>
</li>
<li>
<p>MODULUS(최대표현자리수)를 형성하는데 서로 보완관계에 있는 두수사이의 관계를 Two’s COMPLEMENT라 함<br>
EX) 10진수에서의 보수</p>
</li>
<li>
<p>1진 보수(One’s) : A+B = 9. A+B = 99</p>
</li>
<li>
<p>2진 보수(Two’s) : A+B = 10 -&gt; 두자리의 표현가짓수 형성?, A+B=100</p>
</li>
<li>
<p>2진수에서의 보수</p>
<ul>
<li>1진보수 : A+B =1, 11, 111</li>
<li>2진보수 : A+B=10, A+B=100, 1000</li>
</ul>
</li>
<li>
<p>2진수의 1의 보수는 자신의 수와 반대(1&lt;-&gt;0)로 바꾸면 되고, 2의 보수는 1의 보수에 +1, 또는 주어진 수의 우단으로부터 최초의 유효 BIT까지는 그대로 두고 나머지를 모두 반대(1&lt;-&gt;0)로 바꾸면 된다.</p>
</li>
</ul>
<p><a href="https://st-lab.tistory.com/189">보수 내용 참조</a></p>
<h2 id="정수-표현">정수 표현</h2>
<ul>
<li>
<p>부호화 절대치</p>
<ul>
<li>
<p>±를 표현하기위해 앞자리 sign bit</p>
<ul>
<li>그런데 이를 단순히 1 / 000 0001 과 0 / 000 0001로 표현할시 실제 연산이 매우 복잡해짐</li>
<li>이를 표현하기위해 보수로 음수값을 표현!</li>
</ul>
</li>
<li>
<p>2진 보수의 장점</p>
<ul>
<li>연산 방식이 쉬워짐
<ul>
<li>0 / 000 0010<sub>(2)</sub> (2) 의 음수를 보수로 표현하면<br>
1진 보수 : 1/ 111 1101<sub>(2)</sub><br>
2진 보수 : 1/ 111 1110<sub>(2)</sub> =&gt; -2<sub>(10)</sub></li>
</ul>
</li>
<li>이경우 0 / 000 0010<sub>(2)</sub>+1/ 111 1110<sub>(2)</sub> = 0 0/000 0000 인데 오버플로우로 맨 앞자리는 떼지므로 0/000 0000 이며 이는 0!</li>
<li>단순 덧셈만으로 음수연산과 뺄셈이 가능해진다.</li>
<li>또한 보수를 사용하지않을경우 +0과 -0이 존재하는 문제점이 있지만 2진 보수를 사용할경우 0/ 000 0000 의 보수는 1 0/000 0000이므로 오버플로우로 +0 = -0 이 되어 0이 하나만 존재하게 된다!</li>
</ul>
</li>
</ul>
</li>
<li>
<p>10진수 정수 표현법</p>
<ul>
<li>unpacked decimal
<ul>
<li>zoned decimal이라고 하며 1 byte당 숫자 하나만 표현하는 방식으로 연산에는 사용 x</li>
</ul>
</li>
<li>packed decimal
<ul>
<li>연산용으로 1 byte당 2자의 10진수 표현, 입출력으론 불가능</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="실수-표현">실수 표현</h2>
<ul>
<li>
<p>과학적 표기의 지수를 사용하여 소숫점의 위치를 이동시킬 수 있는 표현방법</p>
</li>
<li>
<p>표현의 범위가 확대</p>
</li>
<li>
<p>비트 수에 따른 분류가 가능</p>
<ul>
<li>단일 정밀도 부동 소숫점 형식</li>
</ul>
<blockquote>
<p>32비트중 1비트는 사인비트, 7비트는 지수필드 24비트는 기수 필드</p>
</blockquote>
<pre><code>  0 0000101 1001 0000 0000 0000 0000 0000
</code></pre>
<ul>
<li>이 경우 부포 +, 지수 5, 기수 0.1001로, +0.1001* 2<sup>5</sup></li>
</ul>
</li>
</ul>
<h2 id="디지털-코드">디지털 코드</h2>
<ul>
<li>BCD 코드 : 2진법 4자리 단위로 하나의 10진수 자릿수를 담는 방식</li>
</ul>

<table>
<thead>
<tr>
<th>10진수</th>
<th>BCD코드</th>
</tr>
</thead>
<tbody>
<tr>
<td>0</td>
<td>0000</td>
</tr>
<tr>
<td>1</td>
<td>0001</td>
</tr>
<tr>
<td>2</td>
<td>0010</td>
</tr>
<tr>
<td>…</td>
<td>…</td>
</tr>
<tr>
<td>9</td>
<td>1001</td>
</tr>
<tr>
<td>10</td>
<td>0001 0000</td>
</tr>
</tbody>
</table><p>자릿수가 넘어가면 2진법 4자리를 새로만들어서 10진법의 다음자릿수에 매핑</p>
<h2 id="에러검출-코드">에러검출 코드</h2>
<ul>
<li>패리티 비트</li>
<li>해밍비트</li>
<li>이런 에러검출코드가 발전해서 해시코드가 됨!</li>
</ul>

