---


---

<h2 id="프로세스">프로세스</h2>
<p>실행중인 프로그램<br>
- 프로세스 : 메모리에 로드되어 실행중<br>
- 코드 이미지(바이너리) : ELF format<br>
응용프로그램 =! 프로세스<br>
- 응용프로그램은 여러개의 프로세스로 이뤄질 수 도 있음</p>
<h2 id="스케쥴링-알고리즘">스케쥴링 알고리즘</h2>
<p>목표 예시<br>
- 시분할 시스템 : 프로세스 응답시간을 가능한 짧게<br>
- 멀티프로그래밍 : CPU활용도를 최대한 높여서</p>
<h4 id="fifo">FIFO</h4>
<ul>
<li>가장 간단한 스케쥴러(배치 처리 시스템)</li>
<li>FCFS(First Come First Served)</li>
<li>가장 단순한 큐 형태</li>
</ul>
<h4 id="sjfshortest-job-first">SJF(Shortest Job First)</h4>
<ul>
<li>가장 프로세스 실행시간이 짧은 프로세스부터 먼저 실행시키는 알고리즘</li>
<li>프로세스의 실행시간을 측정 가능한가?</li>
</ul>
<blockquote>
<p>RTOS : RealTime OS, 응용 프로그램 실시간 성능 보장을 목표로하는 OS</p>
<ul>
<li>정확하게 프로그램 시작, 완료 시간을 보장, 공장등 특정작업에서 정확한 시간을 보장해야할때 사용, SJF같은 알고리즘은 이럴때 사용가능</li>
</ul>
</blockquote>
<blockquote>
<p>GPOS : General Purpose OS, 프로세스실행시간에 민감하지 않고 일반적인 목적으로 사용되는 OS, 윈도우, 리눅스 등등</p>
</blockquote>
<h4 id="우선순위-기반-스케쥴러">우선순위 기반 스케쥴러</h4>
<ul>
<li>Priority-based 스케쥴러
<ul>
<li>정적 우선순위
<ul>
<li>프로세스마다 우선순위를 미리 지정</li>
</ul>
</li>
<li>동적 우선순위
<ul>
<li>스케쥴러가 상황에 따라 우선순위를 동적으로 변경</li>
</ul>
</li>
</ul>
</li>
</ul>
<h4 id="round-robin-스케쥴러">Round-Robin 스케쥴러</h4>
<ul>
<li>프로세스가 끝나지 않아도 실행프로세스를 교체, 시분할 시스템을 가정</li>
</ul>
<h4 id="멀티프로그래밍">멀티프로그래밍</h4>
<ul>
<li>CPU 활용도 극대화하는 스케쥴링 알고리즘</li>
<li>실행중인 프로세스가 대기상태(Wait)로 빠질때 다른 프로세스를 실행하는 알고리즘</li>
</ul>
<blockquote>
<p>프로세스 상태 정보<br>
프로세스 생성 - 실행가능ready -(대기blocked)- 실행중running - 종료</p>
<ul>
<li>대기상태 : 특정 이벤트 발생 대기상태</li>
</ul>
</blockquote>
<ul>
<li>멀티 프로그래밍 상황에서는 단순 프로세스의 정보만으로는 우선순위 계산이 불가능</li>
<li>따라서 3개의 큐를 활용해 이를 계산함!</li>
</ul>
<blockquote>
<p>ReadyState Q<br>
RunningState Q<br>
BlockState Q</p>
</blockquote>
<h4 id="선점형-스케쥴러와-비선점형-스케쥴러">선점형 스케쥴러와 비선점형 스케쥴러</h4>
<ul>
<li>선점형 : 하나의 프로세스가 다른프로세스 대신에 프로세스를 차지할 수 있음 (시분할 멀티 태스킹), 요즘은 디폴트</li>
<li>비선점형 : 하나의 프로세스가 끝나지 않으면 다른 프로세스는 CPU 이용 불가(배치), 자발적으로 block상태로 들어갈때만 교체가능</li>
</ul>
<h2 id="인터럽트">인터럽트</h2>
<ul>
<li>CPU가 프로그램을 실행하고 있을때 IO등의 장치나 예외상황이 발생하여 처리가 필요한 경우 CPU에 알려서 처리하는 기술</li>
<li>일종의 이벤트</li>
<li>예시
<ul>
<li>입출력 하드웨어 등에서 이슈 발생(I/O 인터럽트)
<ul>
<li>파일 처리 끝날때 운영체제에 알려주기</li>
<li>운영체제는 해당프로세스를 Block상태에서 ready상태로 변경</li>
</ul>
</li>
<li>예외상황
<ul>
<li>0으로 나누는계산실행시 운영체제에 알리기</li>
<li>운영체제가 해당 프로세스 실행 중지 / 에러 표시</li>
</ul>
</li>
<li>선점형 스케쥴러를 위해 타이머 인터럽트 존재
<ul>
<li>일정시간마다 운영체제에 인터럽트 발생하여 cpu의 작업을 교체</li>
</ul>
</li>
</ul>
</li>
<li>인터럽트 구분
<ul>
<li>내부 인터럽트(소프트웨어)
<ul>
<li>주로 프로그램 내부에서 잘못된 명령 또는 잘못된 데이터 사용시</li>
</ul>
</li>
<li>외부 인터럽트(하드웨어)
<ul>
<li>주로 하드웨어에서 발생하는 이벤트</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="시스템콜-인터럽트와-시스템콜">시스템콜 인터럽트와 시스템콜</h3>
<ul>
<li>시스템콜도 사실 인터럽트의 한 종류</li>
<li>시스템콜에 해당하는 코드가 실행시 (ex open())
<ul>
<li>eax 레지스터에 해당하는 시스템콜 번호를 넣고 ebx 레지스터에 인자값을 넣은뒤</li>
<li>소프트웨어 인터럽트(0x80) 명령을 호출</li>
<li>CPU는 사용자모드를 커널모드로 변환</li>
<li>IDT에서 0x80에 해당하는 주소를 찾아서 실행(인터럽트 실행</li>
<li>CPU는 레지스터를 보고(eax,ebx) 해당 시스템콜(커널함수)을 실행</li>
<li>이후 다시 사용자모드로 변환후 프로세스의 다음 코드 실행</li>
</ul>
</li>
</ul>
<h3 id="인터럽트와-idt">인터럽트와 IDT</h3>
<ul>
<li>인터럽트는 미리 정의되어 각각 번호와 실행 코드를 가리키는 주소가 IDT에 존재
<ul>
<li>리눅스의경우
<ul>
<li>0~31 소프트웨어 인터럽트</li>
<li>32~47 하드웨어 인터럽트</li>
<li>128 시스템콜</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="프로세스와-컨텍스트-스위칭">프로세스와 컨텍스트 스위칭</h2>
<ul>
<li>프로세스의 구조
<ul>
<li>text(code) : 코드</li>
<li>data :
<ul>
<li>변수(BSS)</li>
<li>초기화 데이터(DATA)</li>
</ul>
</li>
<li>stack : 임시 데이터(함수 호출/로컬변수등)</li>
<li>heap : 코드에서 동적으로 만들어지는 데이터</li>
</ul>
</li>
</ul>

<table>
<thead>
<tr>
<th></th>
</tr>
</thead>
<tbody>
<tr>
<td>스택</td>
</tr>
<tr>
<td>↓</td>
</tr>
<tr>
<td>빈 메모리</td>
</tr>
<tr>
<td>↑</td>
</tr>
<tr>
<td>힙</td>
</tr>
<tr>
<td>데이터</td>
</tr>
<tr>
<td>코드</td>
</tr>
</tbody>
</table><ul>
<li>PC(Program Counter) : 현재 코드의 메모리 주소</li>
<li>SP(Stack Pointer) : 현재 스택의 메모리 주소</li>
<li>EBP 레지스터 : 스택의 최상단 함수 주소를 들고있음(에러시 트래킹용)</li>
<li>EAX 레지스터 : 가장 마지막 함수의 반환값을 갖고있음</li>
</ul>
<h3 id="pcb프로세스-제어-블록">PCB(프로세스 제어 블록)</h3>
<p>컨텍스트 스위칭시 기존 작업의PC와 SP 레지스터값을 저장하는 자료구조 프로세스마다 각각 존재함<br>
- PID<br>
- PC, SP<br>
-  프로세스 상태<br>
- 메모리사이즈 제한 등등<br>
- 프로세스가 실행중인 상태를 스냅샷화해서 저장하고있다고 이해</p>
<h3 id="컨텍스트-스위칭">컨텍스트 스위칭</h3>
<ul>
<li>
<p>문맥교환, CPU에 실행할 프로세스를 교체하는 기술</p>
</li>
<li>
<p>많은 오버헤드를 피하기 위해 어셈블리어로 작성</p>
</li>
<li>
<p>주요 과정</p>
<ol>
<li>실행 중지할 프로세스정보를 해당 프로세스 PCB에 업데이트해서 메인 메모리(운영체제마다 조금씩다름)에 저장</li>
<li>다음 실행할 프로세스 정보를 메인 메모리에 있는 PCB를 찾아 CPU에 갱신하고 다음 프로세스를 실행
<ul>
<li>디스패치 : READY -&gt; RUNNING</li>
</ul>
</li>
</ol>
</li>
</ul>
<blockquote>
<p>컴파일러</p>
<ul>
<li>초기 컴퓨터 프로그램들은 어셈블리어로 작성<br>
- 서로 다른 CPU 아키텍처가 등장할때마다 매번 똑같은 프로그램 다시작성<br>
- 이식성이 떨어짐</li>
<li>컴파일러 등장<br>
- 컴파일러 프로그램이 아키텍처 위에서 번역해줌<br>
- 어셈블리어 코드보단 속도 떨어짐</li>
</ul>
</blockquote>
<h2 id="ipc">IPC</h2>
<p>프로세스간 커뮤니케이션</p>
<ul>
<li>원칙적으로 프로세스간 공간 침범은 허용 X</li>
<li>하지만 멀티 프로세스 프로그램이 멀티 코어에서 실행될경우 퍼포먼스가 매우 빠를테고 이때 프로세스간 통신이 필요하기때문에 IPC 기술이 필요함!, 병렬처리!</li>
</ul>
<h3 id="파일을-사용한-커뮤니케이션">파일을 사용한 커뮤니케이션</h3>
<ul>
<li>
<p>간단히 다른 프로세스에 전달할 내용을 파일로 작성하여 저장하고 다른 프로세스는 정해진 위치에 저장된 파일을 읽어 해당 로직을 수행</p>
</li>
<li>
<p>실시간으로 직접 원하는 프로세스에 데이터 전달이 어려움(실시간 갱신을 어떻게 알리지?)</p>
</li>
<li>
<p>저장매체를 사용하는 만큼 느림</p>
</li>
</ul>
<h3 id="프로세스의-공유하는-커널공간을-사용한-ipc">프로세스의 공유하는 커널공간을 사용한 IPC</h3>
<ul>
<li>리눅스를 예를 들때 하나의 프로세스는 최대 4GB 메모리 용량을 가짐 이중 1GB는 커널영역</li>
<li>모든 프로세스의 1GB가 운영체제 커널영역이면 프로세스를 여러개띄울때 메모리 낭비가 극심하므로 이를 공유공간으로 처리함</li>
</ul>
<h3 id="파이프를-이용한-커뮤니케이션">파이프를 이용한 커뮤니케이션</h3>
<ul>
<li>부모 프로세스 =&gt; 자식 프로세스(fork())
<ul>
<li>기본 파이프는 단방향</li>
<li>fork() 기존 실행중인 프로세스를 완벽히 복사</li>
<li>이때 pid는 다름</li>
</ul>
</li>
<li>파이프라인은 메모리 커널공간에 생성</li>
<li>pipe()</li>
</ul>
<h3 id="메시지-큐를-이용한-커뮤니케이션">메시지 큐를 이용한 커뮤니케이션</h3>
<ul>
<li>부모자식간이 아닌 어느 프로세스간에도 통신 가능</li>
<li>먼저 넣은 데이터 순차대로 메시지가 넘어감</li>
<li>양방향 가능</li>
<li>메시지 큐는 메모리 커널공간에 생성</li>
<li>msqsnd() / msqrcv() / msqid = msgget()</li>
</ul>
<h3 id="공유메모리를-이용한-커뮤니케이션">공유메모리를 이용한 커뮤니케이션</h3>
<ul>
<li>노골적으로 메모리 커널공간에 공유공간을 만들고 프로세스들이 메세지를 기록/읽기를 하게 하는공간, 변수처럼 사용</li>
<li>shmid = shmget() / shmaddr = shmat() / strcpy()</li>
</ul>
<h3 id="signal을-이용한-커뮤니케이션">SIGNAL을 이용한 커뮤니케이션</h3>
<ul>
<li>커널에서 프로세스로 이벤트 발생여부를 알려주는 기법</li>
<li>프로세스관련 코드에 시그널 핸들러를 등록하고 해당 시그널 처리를 실행</li>
<li>리눅스는 기본 64개의 시그널이 제공됨 이중 SIGUSR1,2은 껍데기만 있는데 여길 재정의해서 커뮤니케이션 용도로 사용가능</li>
<li>커널에서 날라온 시그널은 프로세스의 PCB에서 수신하고 관리, 처리
<ul>
<li>커널모드로 특정 수행후 사용자모드로 복귀시 PCB의 시그널 여부를 최종적으로 확인하게됨 이때 시그널이있으면 커널모드로 처리를 마저하고 이후 사용자모드로 복귀</li>
</ul>
</li>
</ul>
<h3 id="소켓을-이용한-커뮤니케이션">소켓을 이용한 커뮤니케이션</h3>
<ul>
<li>네트워크 통신을 위한 기술이지만 IPC에도 사용 가능</li>
</ul>

