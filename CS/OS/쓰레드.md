---


---

<h2 id="쓰레드">쓰레드</h2>
<ul>
<li>lightweight process 라고도 불림</li>
<li>프로세스간 데이터 접근이 불가능 IPC라는 번거로움</li>
<li>하나의 프로세스에 여러 쓰레드 생성가능
<ul>
<li>스레드들은 동시에 실행가능하며 프로세스안에있으므로 프로세스의 데이터를 모두 공유 가능함</li>
</ul>
</li>
</ul>
<h3 id="어떻게-동작하나">어떻게 동작하나?</h3>
<ul>
<li>기본적으로 쓰레드도 프로세스의 하나의 함수</li>
<li>스택영역에 쓰레드가 올라가면 해당 쓰레드에 할당되는 공간이 스택과 힙사이 어딘가에 생김</li>
<li>그 공간에 쓰레드만을 위한 PC,SP가 각각 생김</li>
<li>즉 쓰레드는 스택안에서만 분리된거지 힙, 코드 데이터영역을 모두 공유함</li>
</ul>
<h3 id="멀티-프로세싱과-쓰레드">멀티 프로세싱과 쓰레드</h3>
<ul>
<li>멀티태스킹 : 1CPU가 여러 프로세스 실행</li>
<li>멀티프로세싱 : 여러 CPU가 하나의 프로세스를 실행 OR  여러 프로세스를 여러 CPU가 실행
<ul>
<li>멀티 프로세싱에서 프로세스를 여러 CPU에 할당하는 기준은 바로 <strong>쓰레드</strong></li>
<li>멀티 쓰레드 기반 WAS가 싱글 스레드 기반보다 높은 CPU연산을 필요한 서비스 로직시 더 유리한 이유 BUT 싱글스레드 기반(노드)은 비동기 프로그래밍으로 대기시간이없어서 일반적인 상황에선 더 빠를수도 있음 케바케</li>
</ul>
</li>
</ul>
<h3 id="쓰레드의-장점">쓰레드의 장점</h3>
<ul>
<li>사용자 응답성 향상</li>
<li>자원 공유효율</li>
<li>작업이 분리되어 코드가 간결</li>
</ul>
<h3 id="쓰레드의-단점">쓰레드의 단점</h3>
<ul>
<li>스레드중 한 스레드만 문제있어도 전체 프로세스가 영향받음</li>
<li>많은 스레드 =&gt; 많은 컨텍스트 스위칭 =&gt; 성능저하</li>
</ul>
<h2 id="동기화-이슈">동기화 이슈</h2>
<ul>
<li>
<p>동기화 : 작업들 사이에 실행 시기를 맞추는 것</p>
</li>
<li>
<p>여러 쓰레드가 동일한 자원(데이터)를 접근할 때 발생하는 문제</p>
<ul>
<li>동일 자원을 여러 쓰레드가 동시 수정시, 각 스레드에 영향을 줌</li>
<li>어느 한 스레드가 공유변수를 갱신하는 동안 다른 스레드가 동시 접근하지 못하도록 막아라</li>
</ul>
</li>
<li>
<p>Mutual exclusion(상호배제)를 통해서 해결<br>
- 임계 자원 / 임계 영역(일종의 라킹)<br>
- binary semaphore : 라킹시 임계영역에 하나의 쓰레드만 출입가능<br>
- semaphore : 임계영역에 여러 쓰레드가 출입가능 counter를 두어 접근가능한 쓰레드수 제어</p>
</li>
</ul>
<h3 id="세마포어">세마포어</h3>
<pre><code>	P(S){
	while(S&lt;0)	// 입장가능한 공간이없을경우 무한루프
	S--}   // 임계영역 입장
	임계영역 코드 
	V(S){S++}   // 임계영역 퇴장
</code></pre>
<p>사실상 쓰레드를 대기시키며 CPU를 점유시키는 BUSY WAITING이며 성능문제를 야기</p>
<ul>
<li>대기큐를 이용해서 위의 문제 해결 가능
<ul>
<li>S–를 먼저실행하고 S&lt;0일경우  쓰레드를 대기큐에 집어넣고 블록 (즉 세마포어 변수가 마이너스를 가지고 이 마이너스만큼 대기큐가 존재함을 의미)</li>
<li>S++될때 S가 마이너스라면 대기큐가 존재함을 의미하므로 wakeup()코드를 날려 대기큐의 blocked된 쓰레드를 깨워 실행</li>
</ul>
</li>
</ul>
<h3 id="교착상태deadlock">교착상태(deadlock)</h3>
<ul>
<li>
<p>무한 대기 상태 : 여러 쓰레드가 서로 상대방의 작업이 끝나기만 기다리고 있어 다음단계로 진행되지 못하는 상태</p>
</li>
<li>
<p>실무에서는 사실상 코드단위로 상황에 따라 대처법이 다 다름</p>
</li>
<li>
<p>교착상태 발생조건 : 4개조건이 모두 부합될때 발생</p>
<ol>
<li>상호배제 : 프로세스들이 필요로하는 자원에 대해 배타적 통제권요구</li>
<li>점유대기 : 자원을 점유한상태에서 다른 자원 대기</li>
<li>비선점 : 선점기법x</li>
<li>순환대기 : 각 프로세스는 순환적으로 다음 프로세스 요구자원 보유</li>
</ol>
</li>
<li>
<p>교착상태 해결</p>
<ul>
<li>위의 조건중 하나를 제거</li>
</ul>
</li>
</ul>
<h3 id="기아상태starvation---sjf">기아상태(starvation) - SJF</h3>
<ul>
<li>
<p>특정 프로세스의 우선순위가 낮아서 원하는 자원을 계속 할당받지 못하는 상태</p>
</li>
<li>
<p>교착상태와 기아상태</p>
<ul>
<li>교착상태는 여러 프로세스가 동일자원 점유를 요청할 때 발생</li>
<li>기아상태는 여러 프로세스가 부족한 자원을 점유하기위해 경쟁할 때, 특정 프로세스는 영원히 자원할당이 안되는 경우</li>
</ul>
</li>
<li>
<p>우선순위를 변경하는 방식으로 해결가능</p>
</li>
<li>
<p>오래 기다린 프로세스에 우선순위 올려주기 =&gt; HRN</p>
</li>
</ul>

