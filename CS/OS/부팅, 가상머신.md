---


---

<h2 id="부트">부트</h2>
<ul>
<li>
<p>컴퓨터를 켜서 동작시키는 절차</p>
</li>
<li>
<p>폰노이만구조 특성상 실행되는 프로세스는 항상 메모리에 로드되있어야함</p>
</li>
<li>
<p>처음 컴퓨터를 킬때 Storage에서 메모리로 누가 운영체제 프로세스를 로드시키지?</p>
</li>
<li>
<p>부트 프로그램</p>
<ul>
<li>
<p>운영체제 커널을 Storage에서 특정 주소의 물리 메모리를 복사하고 커널의 처음 실행 위치로 PC를 가져다 놓는 프로그램</p>
</li>
<li>
<p>ROM속의 BIOS 프로그램이 그 역할</p>
</li>
<li>
<p>최초 부트시 ROM의 BIOS가 메모리로 로드</p>
</li>
<li>
<p>BIOS는 저장매체(MBR)에서 부트 로더를 불러오고</p>
</li>
<li>
<p>부트로더는 저장매체(부트섹터)에서 부트 코드를 불러오고</p>
</li>
<li>
<p>부트코드는 저장매체(커널이미지)에서 운영체제프로세스를 메모리로 로드시킴</p>
</li>
</ul>
</li>
</ul>
<h2 id="가상머신">가상머신</h2>
<p>하나의 하드웨어에 다수의 운영체제를 설치하고, 개별 컴퓨터처럼 동작하도록하는 프로그램</p>
<blockquote>
<p>사실상 학부 레벨을 넘어서므로 간단히만 살펴보자</p>
</blockquote>
<h4 id="구분-기준">구분 기준</h4>
<p>타입 1 : 하드웨어 - VMM - 가상머신 구조<br>
타입 2 : 하드웨어 - 호스트 OS - VMM - 가상머신 구조</p>
<p>전가상화  : VMM이 하드웨어와 가상머신 사이에서 모든걸 중재<br>
반가상화 : VMM은 리소스관리만하고 가상머신 내부 OS가 하드웨어에 맞게끔 튜닝되거나 전처리되어 소통하는 구조</p>
<h4 id="vmm-vmw와-kvm">VMM: VMW와 KVM</h4>
<p>VMW : 윈도우에서 리눅스를 돌릴때 쓰는 VMM<br>
KVM : 클라우딩 컴퓨팅 서비스에서 많이 사용</p>
<h3 id="도커">도커</h3>
<p>가상머신은 컴퓨터 하드웨어를 가상화한 개념(하드웨어 전체를 추상화)</p>
<ul>
<li>하이퍼바이저 사용, 추가 OS 필요등 성능 저하 이슈 존재</li>
</ul>
<p>DOCKER는 운영체제 레벨에서 별도로 분리된 실행환경을 제공(커널 추상화)<br>
리눅스 컨테이너기반<br>
MAC이나 윈도우에 설치할 경우는 가상 머신 기반 제공</p>
<ul>
<li>BAREMETAL방식이 가장 성능이 좋음(타입 1)
<ul>
<li>하드웨어 직접 엑세스하므로</li>
<li>AWS환경도 BAREMETAL기반 가상머신 기술 활용</li>
</ul>
</li>
<li>DOCKER 는 경량 이미지로 실행환경을 통째로 백업, 실행가능</li>
</ul>
<h3 id="jvm">JVM</h3>
<p>응용프로그램 레벨에서의 가상화로 가상머신과는 목적이 다름</p>

