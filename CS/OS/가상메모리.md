---


---

<h2 id="가상메모리-도입-배경">가상메모리 도입 배경</h2>
<ul>
<li>실제 각 프로세스마다 충분한 메모리를 할당하기에는 메모리 크기의 한계가 있음</li>
<li>리눅스는 통상 하나의 프로세스에 4GB메모리를 할당해야함</li>
<li>폰 노이만 구조기반이므로, 코드는 메모리에 존재해야함!</li>
<li>구동 가능한 프로세스는 물리적으로 한계…</li>
</ul>
<h3 id="기본-아이디어">기본 아이디어</h3>
<ul>
<li>
<p>실제로 프로세스에서 사용하고 있는 공간만 물리적 메모리에 로드하자는 것이 가상메모리의 핵심 아이디어!</p>
</li>
<li>
<p>프로세스는 가상주소를 사용하고, 실제 해당 주소에서 데이터를 읽고 쓸때만 물리주소로 올려서 사용</p>
</li>
<li>
<p>가상주소 : 프로세스가 참조하는 주소</p>
</li>
<li>
<p>물리주소 : 실제 주소</p>
</li>
<li>
<p>가상주소 -&gt; 물리주소 변환하는 작업의 오버헤드를 줄이기 위해 MMU(Memory Management Unit) 을 사용</p>
<ul>
<li>cpu에 코드 실행시, 가상 주소 메모리 접근이 필요할 때, 해당 주소를 물리 주소값으로 변환해주는 하드웨어장치</li>
</ul>
</li>
</ul>
<h3 id="아키텍처-정리">아키텍처 정리</h3>
<ol>
<li>CPU -&gt; MMU : CPU는 가상주소를 알고있고 MMU에 가상주소를 요청</li>
<li>실행되고있는 프로세스는 현재 물리메모리에 놓여있으므로 가상주소로 타고넘어가면 가상메모리의 프로그램으로 연결됨</li>
<li>MMU는 여기서 가상주소의 실제 메모리 주소 매핑을 보고 실제 메모리의 어디에 접근해야할지를 찾아줌(번역기)</li>
<li>CPU는 가상주소만으로 물리 주소로 접근 가능하게됨!</li>
</ol>
<h2 id="페이징">페이징</h2>
<ul>
<li>크기가 동일한 사이즈로 가상공간 주소와 이에 매칭하는 물리공간 주소를 관리</li>
<li>하드웨어 지원 필요
<ul>
<li>EX) INTEL X86은 4KB 2MB 1GB단위로 지원</li>
</ul>
</li>
<li>리눅스는 4KB 단위 페이징</li>
<li>페이지 번호를 기반으로 주소 매핑 기록/ 사용</li>
<li><strong>PCB에 페이지 테이블이 존재</strong>(가상주소,물리주소 매핑정보)</li>
</ul>
<h3 id="페이지-테이블">페이지 테이블</h3>
<ul>
<li>
<p>물리주소에 있는 페이지 번호와 해당 페이지의 첫 물리주소 정보를 매핑한 표</p>
<ul>
<li>가상주소 V(P,D)
<ul>
<li>P: 페이지번호</li>
<li>D: P 페이지 처음부터 얼마나 떨어져있는지 정확한 좌표(변위, 오프셋)</li>
</ul>
</li>
<li>가상주소에 매핑된 물리주소</li>
<li>물리주소가 있는지 여부를 나타내는 비트정보</li>
</ul>
</li>
<li>
<p>해당 프로세스에서 특정 가상주소에 엑세스하려면</p>
<ul>
<li>해당 프로세스의 PCB의 페이지테이블에서 해당 가상주소가 포함된 페이지번호 확인(BASE 주소 + 페이지)</li>
<li>페이지 번호가 있으면 이 페이지의 실제 물리주소를 알아내고 거기에 +D를 하여 정확한 물리주소 알아냄</li>
</ul>
</li>
</ul>
<h3 id="mmu와-pcb-가상메모리-물리메모리-모든-개념으로-다시-정리해보자">MMU와 PCB 가상메모리, 물리메모리 모든 개념으로 다시 정리해보자</h3>
<ol>
<li>프로세스 생성시 페이지 테이블정보생성</li>
<li>페이지 테이블 정보는 PCB에 저장하고 물리메모리에 적재</li>
<li>프로세스 구동시 해당 프로세스의 페이지 테이블의 BASE주소는 CR3이라는 별도 레지스터에 저장</li>
<li>CPU가 프로세스 구동위해 특정 가상주소를 MMU에 요청</li>
<li>MMU가 CR3, PCB의 페이지 테이블을 참조 물리주소를 가져옴</li>
<li>해당 물리주소를 접근하여 데이터를 CPU에 전달하면 CPU는 해당 데이터로 연산</li>
</ol>
<h3 id="다중-단계-페이징-시스템">다중 단계 페이징 시스템</h3>
<ul>
<li>
<p>32bit 시스템에서 4kb페이지를 위한 페이징 시스템은</p>
<ul>
<li>하위 12bit는 오프셋(변위)</li>
<li>나머지 20bit는 페이징 번호가 테이블에 저장됨</li>
</ul>
</li>
<li>
<p>만약 프로그램 크기가 4gb미만인경우 리눅스는 하나의 프로세스를 4gb로 인식하고 4gb 사이즈의 가상 메모리 주소를 계산하며, 실제 프로세스 크기를 뺀 여분의 용량만큼 허수 페이지가 작성되고 테이블에 더미로 저장될 위험이있음(1kb 프로그램도 실행시키면 4gb의 가상메모리주소가 생성!)</p>
</li>
<li>
<p>이를 막기위해 다중 단계 페이징 시스템으로 페이징 정보를 단계를 나누어 생성하여 메모리 공간을 절약</p>
</li>
</ul>
<p>=&gt; 20bit의 공간에 10bit 10bit 를 나누어 10bit에는 페이지 디렉토리를 저장하여 사용 여기서 불필요한 디렉토리의 페이지테이블은 미생성!</p>
<h3 id="tlb-translation-lookaside-buffer--페이지-정보-캐시">TLB (Translation Lookaside Buffer) : 페이지 정보 캐시</h3>
<p>최근 접근해본 가상주소 - 물리주소 매핑정보를 캐싱해놨다가 재접근시 페이지 테이블을 안뒤지고 바로 물리 메모리로 접근하도록 도와주는 하드웨어</p>
<ul>
<li>fork()의 실제 작동 방식( 좀더 공부해봐야겠다 )
<ul>
<li>fork를 하더라도 해당 프로세스를 그대로 복사하는게 아님</li>
<li>실행되고 있는 프로세스의 물리주소를 가리키는 페이지 테이블을 그대로 복사하여 fork된 자식 프로세스도 해당 물리주소를 그대로 공유하게됨</li>
<li>프로세스를 쓰거나 수정하게되어 fork된 자식과 부모가 달라지는 이벤트가 발생하면 해당 이벤트에 속하는 페이지만 이때 복사되게 됨</li>
</ul>
</li>
</ul>
<h3 id="페이징-fault-interrupt">페이징 fault interrupt</h3>
<ul>
<li>어떤 페이지가 실제 물리 메모리에 없을때 일어나는 인터럽트</li>
<li>운영체제가 page fault가 일어나면 해당 페이지를 물리메모리에 올림</li>
<li>페이지 테이블에 저장되있는 물리주소 여부를 보고 물리주소가 없다? 물리주소에 올리기위해 OS에 인터럽트 요청</li>
<li>OS는 해당 인터럽트를 핸들링</li>
</ul>
<h3 id="페이지-교체-정책알고리즘-전략">페이지 교체 정책(알고리즘, 전략)</h3>
<ul>
<li>
<p>가득찬 물리메모리에서 어떤 페이지를 우선적으로 지울래?</p>
</li>
<li>
<p>FIFO</p>
</li>
<li>
<p>OPT(최적페이지 교체)</p>
<ul>
<li>앞으로 가장 오랫동안 사용하지 않을페이지를 내리자</li>
<li>일반적인 OS에선 구현불가능, 공장등에서 쓰는 정해진 순서라면 가능할듯?</li>
</ul>
</li>
<li>
<p><strong>LRU(가장 오래전에 사용된 페이지 교체)</strong> - 가장 보편적</p>
</li>
<li>
<p>LFU(가장 적게 사용된 페이지 교체)</p>
</li>
<li>
<p>NUR(LRU와 유사)</p>
</li>
</ul>
<h3 id="메모리-지역성">메모리 지역성</h3>
<p>코드가 실행될때 특정 시간대에는 특정 구역에 구동빈도가 높아지는 현상<br>
반복문을 생각해보면 당연함<br>
LRU에서 가장 오래전에 사용된 페이지라는 의미는 메모리 지역성을 생각해볼때 현재 시점에서 가장 먼 지역성을 가지므로 페이징할 논리적 기반이됨</p>
<h3 id="쓰레싱">쓰레싱</h3>
<p>반복적 페이지 폴트가 발생해서 과도한 페이지 교체작업이 일어나 실제로는 아무일도 못하는 현상<br>
페이지 스왑만 일어나느라 cpu가 연산을 못하는중…</p>
<h2 id="세그멘테이션-기법">세그멘테이션 기법</h2>
<p>페이징 기법 이외에 가상 메모리교체기법중 하나<br>
페이징처럼 균일한 단위로 프로세스를 분리하는것이 아닌 의미있는 단위로 프로세스를 분리하여 적재하는 방식<br>
따라서 각 세그먼트의 크기는 모두 다름</p>
<h2 id="단편화">단편화</h2>
<p>가상메모리 사용시 필연적으로 발생되는 물리 메모리의 낭비되는 공간</p>
<ul>
<li>
<p>내부 단편화(페이지 기법)</p>
<ul>
<li>페이지 블록만큼 딱맞게 데이터가 채워지지않을때 발생</li>
<li>마지막 페이지가 4kb중 1kb일경우 3kb 낭비</li>
</ul>
</li>
<li>
<p>외부 단편화(세그먼트 기법)</p>
<ul>
<li>물리 메모리가 원하는 메모리공간을 제공해주지 못하는 경우 발생
<ul>
<li>세그먼트 크기가 정해져있지 않으므로 어쩔수 없음</li>
</ul>
</li>
</ul>
</li>
<li>
<p>단편화는 하드웨어 차원에서 해결해야함</p>
</li>
</ul>

