## OSI 4계층(전송계층)
1계층 ~ 3계층까지의 프로토콜을 잘 준수했다면, 이제 인터넷 네트워크환경에서 단말기간 신호의 송수신은 무리없이 가능해진다.

하지만 IP 프로토콜을 공부하면서 마지막 단락에서 언급했다시피 3계층만으로는 **비연결성과, 비신뢰성** 때문에 

1) 안전한 데이터의 송수신이 불가능하며,
2) 단말기(컴퓨터)가 데이터를 송신했다하더라도, 그 데이터가 정작 쓰일 프로세스까지 도달할지 알 수 없다.

편지로 비유하자면, 편지를 보내기만 했을 뿐, 편지를 받았는지 확인이 불가능하며, 편지가 아파트 X동 X호(IP주소)에 도착은 했지만, X호에 사는 누군가(프로그램)에게 전달될지 모르는 상황인 것이다.

이와같은 상황을 해결하기 위해서는 제 4계층의 프로토콜인 TCP 나 UDP가 필요하다.

## TCP(Transmission Control)
전송 제어 컨트롤 프로토콜, TCP 프로토콜은 IP 프로토콜까지의 패킷에서 TCP헤더를 덧붙여 **세그먼트**라는 단위로 데이터를 취급한다.

![enter image description here](https://t1.daumcdn.net/cfile/tistory/2730574E510884A81C)

TCP 헤더는 위의 그림과 같은 구조를 가지고 있는데, 이중 ACK,SYN,FIN 이라는 코드 비트[0 OR 1]를 통해 통신**연결**을 수행한다.

### 3-WAY 핸드 셰이크

3계층까지의 통신은 사실 단방향 소통으로, 물리적으로 연결은 되있지만 논리적으로는 연결되있지 않아서, 상호간의 연결이란 개념이랑은 거리가 멀었다. 

하지만 TCP프로토콜에서는 
- 최초에 데이터를 목적 단말로 송신하기 전, 미리 SYN 코드비트를 보낸다.[1]

- 수신 단말은 TCP 프로토콜하에 세그먼트속 SYN 코드비트에서 [1]을 확인하고 통신이 가능한경우 응답으로 ACK 코드비트[1]와 상대도 통신이 가능한지를 묻는 SYN[1] 요청을 보낸다.
- 송신 단말은 ACK와 SYN의 코드비트를 통해 상대가 데이터 송신이 준비됬음을 확인하고, 자신도 송수신이 가능함을 확인시켜주기 위해 ACK[1] 코드를 보낸다.

		연결 확립요청->
		 <- 연결확립응답/연결확립요청 
		연결확립요청 ->

다음 세 과정을 통해 두 단말은 서로 송수신이 가능함을 확인함으로서 논리적으로 **연결** 상태를 유지하게 되며

이를 **가상회선** 이라 부르고 가상회선을 연결하는 위의 방법을 **3-WAY 핸드 셰이크**라고 부른다.


### 4-WAY 핸드 셰이크

연결을 종료할 경우도 위의 케이스와 비슷하게

- 단말1에서 단말2로 연결종료요청(FIN) 비트코드를 보낸다.
- 단말2는 연결종료 응답(ACK) 을 반환한다
- 단말2에서는 또한 다시 FIN 비트코드를 보낸다.
- 단말1은 FIN코드의 응답으로 ACK 코드를 반환한다.

4번의 과정을 거쳐 연결을 종료하게된다.


### **비신뢰성**은 어떻게 해결하지? 오류제어

3WAY 핸드셰이크를 사용하여 논리적인 **연결**을 하고, 데이터를 보낼때 상대가 송신을 제대로 하는지 확인은 가능해졌지만, 아직 **비신뢰성**의 문제가 남아있다.

TCP 프로토콜은 헤더의 Sequence Number(일련번호)와 Acknowledge Number(확인 응답번호)를 통해 이를 해결한다.

3계층 IP프로토콜하에서 잘게 쪼개진 패킷은 순차적으로 송신자가 보내더라도,

 네트워크의 상황에 따라 라우터에게 맡겨져 무작위 순서로 송신자에게 도착하게 된다.

하지만 TCP 프로토콜하에서는  3-WAY핸드셰이크를 통해 가상 회선을 연결한 뒤

 송신단말에 의해 쪼개진 세그먼트가 송신되어 도착했을 때 수신 단말은 TCP 헤더의 **일련번호**를 확인하고 그 다음 순서의 **일련번호**를 **확인응답번호**에 담아 응답한다.

송신단말은 응답을 받고 해당 **일련번호**를 전송하는식으로 마치 핑퐁하듯 신호를 주고받으며 데이터를 전송하게된다. 

![enter image description here](https://mblogthumb-phinf.pstatic.net/20130616_153/printf7_1371378918539cj5mK_PNG/close.png?type=w2)

위의 그림과같이 응답과 요청을 주고받으며 제대로 확인 응답이 안왔을 경우 재전송을 하는 식으로 **오류 제어**가 이루어 지게 된다.

### 지나치게 비효율적인거 아닌가? 흐름제어

모든 세그먼트를 보내고 응답을 기다렸다가 확인이 오면 또 다음을 보내고...

너무 비효율적으로 느껴지지 않는가?

 만약 TCP 프로토콜하의 인터넷 네트워크가 위의 방식으로만 이루어진다면 느린 속도때문에 속이 터질것이다.

다행히도 실제론 세그먼트를 연속으로 보내는 것과 확인 응답을 반환받는 걸 실시간 병렬처리하는 방식으로 이루어진다.

이때 수신단말은 일반적으로 세그먼트가 날라오는 속도보다 세그먼트를 처리하는 속도가 느리기때문에, 필연적으로 **처리할 세그먼트를 쌓아둘** 버퍼가 필요하다.

이 버퍼의 크기는 TCP 헤더에서 **윈도우 사이즈(Window Size)**에 기록하는데, 3-WAY 핸드셰이크단계에서 송수신단말은 서로의 윈도우사이즈를 파악한다.

따라서 송신 단말은 수신 단말이 한번에 쌓아둘 세그먼트의 최대양을 윈도우사이즈를 통해 기억하여 한도까지 세그먼트를 미리 보낼수 있고

수신단말은 세그먼트가 쌓인 버퍼에서 순차적으로 처리하며 송신단말에게 응답을 보내게 된다.

![enter image description here](https://blog.kakaocdn.net/dn/Wk8Xx/btqFoAIjiIZ/0DvCNehvE2Egbs1JwilCJ0/img.png)

위의 과정을 통해 매 송신마다 응답을 대기할 필요없이 보다 효율적인 데이터 송수신이 가능하며, 윈도우 사이즈를 기억해둠으로서

버퍼가 오버플로우가 나는 일을 방지하는 **흐름제어** 가 가능해진다.

이외에도 TCP 프로토콜은 네트워크 혼잡으로 인한 붕괴상황을 방지하기 위해 다양한 알고리즘으로 **혼잡제어**를 수행하기도 한다.

혼잡제어에 대해서는 다음 기회에 더 자세히 알아보자!

### 포트 번호

앞서 3계층의 한계를 설명하면서 전송된 데이터가 필요로 하는 프로세스를 찾아가지 못한다고 말한바 있다.

TCP 프로토콜에서는 포트번호라는걸 제공하여 데이터를 필요로 하는 프로세스에 전달해 주게된다.

즉, 편지로 비유하자면 IP 주소는 집주소이고, 포트번호는 그 집안에 사는 구성원중 누구를 콕 집어 말하는 셈이다.

네트워크에 연결된 프로세스들은 각각 고유의 포트번호를 지정할 수 있으며, 만약 송신자가 수신자의 특정 애플리케이션에 데이터를 보낼경우

출발지 애플리케이션의 포트와 목적지 애플리케이션의 포트번호를 TCP 헤더에 담아 정확한 데이터 전송을 가능케 하는것이다.

 포트번호는 총 0~65535번까지 사용가능하며

여기서 0~1023번은**잘 알려진 포트**라고 해서 주요 프로토콜이 사용하도록 이미 예약되있어 일반적인 사용이 불가능하다.


### UDP는?

전송계층에서 가장 많이 사용되는 프로토콜은 TCP 이지만, TCP는 연결을위한 핸드셰이크나 흐름제어, 오류제어를 위한 잦은 확인으로 순수한 신호전달의 **효율성** 측면에서는 좋은 평가를 주기 힘들다.

UDP는 TCP와 달리 **비연결형 통신** 프로토콜로서 데이터를 전송할때 확인 작업을 일일히 하지 않는다.

![enter image description here](https://lh3.googleusercontent.com/proxy/4ndd8yPuno8DgMv3lnuPEFoL_ifk9sF3cg73o59hhpuB42V1KOL7i_gZQe1EsWevivAPJQhKo8UJUavM6zs_3LVSilZne56YqbBtZgMjPSg9RFn0BMvA9qPitj0DPW85_tCxTS4gMfBDvZpmIJHyW2pvs7CfD_HqtA)

UDP의 헤더를 보면 송수신 포트와 최소한의 오류제어를 위한 체크섬을 제외하곤 어떠한 절차도 없으며

사실상 IP 프로토콜 위에 포트번호만 올렸다고 봐도 과장이 아닌 구조를 갖고 있다.

따라서 **데이터를 빠르게 보내는데**에 최적화되있으며 스트리밍 방식으로 동영상을 전송하거나, 실시간 음성통화를 하는 인터넷 전화등 특정 서비스를 구현할때에만 사용되는 편이다.

> IP/TCP 프로토콜은 그동안 인터넷 네트워크에서 패러다임을 지배해온 메인 프로토콜이지만, 근래 등장한 HTTP 3.0 프로토콜은 UDP 기반으로 설계되어있다. UDP의 도화지같은 백지위에 애플리케이션의 구체적인 설계를 통해 그간 통신보다 훨씬 빠른 통신이 가능하게 된다는것인데 아직 공부가 부족하여 자세히 알지는 못한다. HTTP3.0에 대해서도 나중에 시간을 내어 공부해보자. 

OSI 4계층(전송계층)
1계층 ~ 3계층까지의 프로토콜을 잘 준수했다면, 이제 인터넷 네트워크환경에서 단말기간 신호의 송수신은 무리없이 가능해진다.

하지만 IP 프로토콜을 공부하면서 마지막 단락에서 언급했다시피 3계층만으로는 비연결성과, 비신뢰성 때문에

안전한 데이터의 송수신이 불가능하며,
단말기(컴퓨터)가 데이터를 송신했다하더라도, 그 데이터가 정작 쓰일 프로세스까지 도달할지 알 수 없다.
편지로 비유하자면, 편지를 보내기만 했을 뿐, 편지를 받았는지 확인이 불가능하며, 편지가 아파트 X동 X호(IP주소)에 도착은 했지만, X호에 사는 누군가(프로그램)에게 전달될지 모르는 상황인 것이다.

이와같은 상황을 해결하기 위해서는 제 4계층의 프로토콜인 TCP 나 UDP가 필요하다.

TCP(Transmission Control)
전송 제어 컨트롤 프로토콜, TCP 프로토콜은 IP 프로토콜까지의 패킷에서 TCP헤더를 덧붙여 세그먼트라는 단위로 데이터를 취급한다.

enter image description here

TCP 헤더는 위의 그림과 같은 구조를 가지고 있는데, 이중 ACK,SYN,FIN 이라는 코드 비트[0 OR 1]를 통해 통신연결을 수행한다.

3-WAY 핸드 셰이크
3계층까지의 통신은 사실 단방향 소통으로, 물리적으로 연결은 되있지만 논리적으로는 연결되있지 않아서, 상호간의 연결이란 개념이랑은 거리가 멀었다.

하지만 TCP프로토콜에서는

최초에 데이터를 목적 단말로 송신하기 전, 미리 SYN 코드비트를 보낸다.[1]

수신 단말은 TCP 프로토콜하에 세그먼트속 SYN 코드비트에서 [1]을 확인하고 통신이 가능한경우 응답으로 ACK 코드비트[1]와 상대도 통신이 가능한지를 묻는 SYN[1] 요청을 보낸다.

송신 단말은 ACK와 SYN의 코드비트를 통해 상대가 데이터 송신이 준비됬음을 확인하고, 자신도 송수신이 가능함을 확인시켜주기 위해 ACK[1] 코드를 보낸다.

  연결 확립요청->
   <- 연결확립응답/연결확립요청 
  연결확립요청 ->
다음 세 과정을 통해 두 단말은 서로 송수신이 가능함을 확인함으로서 논리적으로 연결 상태를 유지하게 되며

이를 가상회선 이라 부르고 가상회선을 연결하는 위의 방법을 3-WAY 핸드 셰이크라고 부른다.

4-WAY 핸드 셰이크
연결을 종료할 경우도 위의 케이스와 비슷하게

단말1에서 단말2로 연결종료요청(FIN) 비트코드를 보낸다.
단말2는 연결종료 응답(ACK) 을 반환한다
단말2에서는 또한 다시 FIN 비트코드를 보낸다.
단말1은 FIN코드의 응답으로 ACK 코드를 반환한다.
4번의 과정을 거쳐 연결을 종료하게된다.

비신뢰성은 어떻게 해결하지? 오류제어
3WAY 핸드셰이크를 사용하여 논리적인 연결을 하고, 데이터를 보낼때 상대가 송신을 제대로 하는지 확인은 가능해졌지만, 아직 비신뢰성의 문제가 남아있다.

TCP 프로토콜은 헤더의 Sequence Number(일련번호)와 Acknowledge Number(확인 응답번호)를 통해 이를 해결한다.

3계층 IP프로토콜하에서 잘게 쪼개진 패킷은 순차적으로 송신자가 보내더라도,

네트워크의 상황에 따라 라우터에게 맡겨져 무작위 순서로 송신자에게 도착하게 된다.

하지만 TCP 프로토콜하에서는 3-WAY핸드셰이크를 통해 가상 회선을 연결한 뒤

송신단말에 의해 쪼개진 세그먼트가 송신되어 도착했을 때 수신 단말은 TCP 헤더의 일련번호를 확인하고 그 다음 순서의 일련번호를 확인응답번호에 담아 응답한다.

송신단말은 응답을 받고 해당 일련번호를 전송하는식으로 마치 핑퐁하듯 신호를 주고받으며 데이터를 전송하게된다.

enter image description here

위의 그림과같이 응답과 요청을 주고받으며 제대로 확인 응답이 안왔을 경우 재전송을 하는 식으로 오류 제어가 이루어 지게 된다.

지나치게 비효율적인거 아닌가? 흐름제어
모든 세그먼트를 보내고 응답을 기다렸다가 확인이 오면 또 다음을 보내고…

너무 비효율적으로 느껴지지 않는가?

만약 TCP 프로토콜하의 인터넷 네트워크가 위의 방식으로만 이루어진다면 느린 속도때문에 속이 터질것이다.

다행히도 실제론 세그먼트를 연속으로 보내는 것과 확인 응답을 반환받는 걸 실시간 병렬처리하는 방식으로 이루어진다.

이때 수신단말은 일반적으로 세그먼트가 날라오는 속도보다 세그먼트를 처리하는 속도가 느리기때문에, 필연적으로 처리할 세그먼트를 쌓아둘 버퍼가 필요하다.

이 버퍼의 크기는 TCP 헤더에서 **윈도우 사이즈(Window Size)**에 기록하는데, 3-WAY 핸드셰이크단계에서 송수신단말은 서로의 윈도우사이즈를 파악한다.

따라서 송신 단말은 수신 단말이 한번에 쌓아둘 세그먼트의 최대양을 윈도우사이즈를 통해 기억하여 한도까지 세그먼트를 미리 보낼수 있고

수신단말은 세그먼트가 쌓인 버퍼에서 순차적으로 처리하며 송신단말에게 응답을 보내게 된다.

enter image description here

위의 과정을 통해 매 송신마다 응답을 대기할 필요없이 보다 효율적인 데이터 송수신이 가능하며, 윈도우 사이즈를 기억해둠으로서

버퍼가 오버플로우가 나는 일을 방지하는 흐름제어 가 가능해진다.

이외에도 TCP 프로토콜은 네트워크 혼잡으로 인한 붕괴상황을 방지하기 위해 다양한 알고리즘으로 혼잡제어를 수행하기도 한다.

혼잡제어에 대해서는 다음 기회에 더 자세히 알아보자!

포트 번호
앞서 3계층의 한계를 설명하면서 전송된 데이터가 필요로 하는 프로세스를 찾아가지 못한다고 말한바 있다.

TCP 프로토콜에서는 포트번호라는걸 제공하여 데이터를 필요로 하는 프로세스에 전달해 주게된다.

즉, 편지로 비유하자면 IP 주소는 집주소이고, 포트번호는 그 집안에 사는 구성원중 누구를 콕 집어 말하는 셈이다.

네트워크에 연결된 프로세스들은 각각 고유의 포트번호를 지정할 수 있으며, 만약 송신자가 수신자의 특정 애플리케이션에 데이터를 보낼경우

출발지 애플리케이션의 포트와 목적지 애플리케이션의 포트번호를 TCP 헤더에 담아 정확한 데이터 전송을 가능케 하는것이다.

포트번호는 총 0~65535번까지 사용가능하며

여기서 0~1023번은잘 알려진 포트라고 해서 주요 프로토콜이 사용하도록 이미 예약되있어 일반적인 사용이 불가능하다.

UDP는?
전송계층에서 가장 많이 사용되는 프로토콜은 TCP 이지만, TCP는 연결을위한 핸드셰이크나 흐름제어, 오류제어를 위한 잦은 확인으로 순수한 신호전달의 효율성 측면에서는 좋은 평가를 주기 힘들다.

UDP는 TCP와 달리 비연결형 통신 프로토콜로서 데이터를 전송할때 확인 작업을 일일히 하지 않는다.

enter image description here

UDP의 헤더를 보면 송수신 포트와 최소한의 오류제어를 위한 체크섬을 제외하곤 어떠한 절차도 없으며

사실상 IP 프로토콜 위에 포트번호만 올렸다고 봐도 과장이 아닌 구조를 갖고 있다.

따라서 데이터를 빠르게 보내는데에 최적화되있으며 스트리밍 방식으로 동영상을 전송하거나, 실시간 음성통화를 하는 인터넷 전화등 특정 서비스를 구현할때에만 사용되는 편이다.

IP/TCP 프로토콜은 그동안 인터넷 네트워크에서 패러다임을 지배해온 메인 프로토콜이지만, 근래 등장한 HTTP 3.0 프로토콜은 UDP 기반으로 설계되어있다. UDP의 도화지같은 백지위에 애플리케이션의 구체적인 설계를 통해 그간 통신보다 훨씬 빠른 통신이 가능하게 된다는것인데 아직 공부가 부족하여 자세히 알지는 못한다. HTTP3.0에 대해서도 나중에 시간을 내어 공부해보자.

Markdown selection 35 bytes 8 words 0 lines Ln 36, Col 57HTML 2775 characters 721 words 65 paragraphs