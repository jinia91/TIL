# chapter 09. 암시적인 개념을 명확하게 - 모델은 도메인의 모든 개념을 최대한 구체적으로 보여줘야한다

## 심층적 모델링 : 개요

- 최초의 시작은 암시적인 개념을 임의의 정제되지 않은 형태로 인식하는것
- 반복적인 리팩토링과정을 거쳐, 성공적으로 개념에 할당된 책임을 조정하고 다른객체와의 관계를 변경하며 이름도 수정

## 개념 파헤치기
### 언어에 귀 기울여라
- 도메인 전문가가 사용하는 언어에 귀 기울여라.  
  - 복잡하게 뒤얽힌 개념들을 간결하게 표현하는 용어?
  - 도메인 전문가와 도메인에 대해 논의하며 기술적인 언어가 아닌, 도메인 언어를 사용하도록 하자

> `Ubiquitous Language`

- 언어, 문서, 모델 다이어그램, 코드에 모두 통용되는 통일된 언어를 사용해 소통하자
- 현재 작동되고 있는 어플리케이션에도 도메인상 핵심 개념이 묵시적으로 존재만 할뿐 모델로 정의되지 않은경우도 많다. 이를 구체화시켜 구현하면 훨씬 좋은 설계로 변경가능

### 어색한 부분을 조사하라
- 현재의 도메인 로직이 무언가 어색하게 느껴진다면 도메인 전문가와 적극적으로 소통하자

### 모순점에 대해 깊이 고민하라
- 도메인 로직과 실제와의 모든 모순을 해소하는것은 현실적이지도, 바람직하지도 않다.
- 그러나 모순되는 사항중 일부는 해결됬을때 더 나은 설계가 되기도한다.

### 서적을 참고해라
- 도메인에 관련된 책들을 읽자
- 바퀴를 다시 발명하지 말자

### 시도하고 또 시도하라
- 리팩터링을 반복적으로 수행하여 설계 품질 향상

## 다소 불명확한 개념을 모델링하는 법
- 때론 "발생" 과 같이 추사엊ㄱ인 개념도 객체 모델로 구성해야할 필요가 있음
- 일반적으론 "동사" 와 "명사" 를 조사해보자
- 하지만 이 외에도 중요한 범주의 개념이 존재할수 있음

### 명시적인 제약조건(`constraint`)
- 제약조건이 객체나 메서드 내에 포함되있는것보다 제약 조건을 별도의 메서드로 분리하는편이 좋음
  - validate or constrainedToCapacity

#### 별도의 제약조건, 검증, 정책 객체가 필요한상황
1. 만약 제약조건을 평가하기위해 본래 비즈니스로직상 필요한 객체의 정의, 책임에 적합하지 않은 데이터가 필요한경우
2. 관련 규칙이 여러객체에 걸쳐 나타나며, 동일한 계층구조에 속하지 않는 객체간에 중복 또는 상속관계를 요구

위와같은 상황이라면 제약조건을 명시적인 객체로 분리, 혹은 나아가 일련의 객체와 관계의 집합으로 모델링할수 있다.(validator 집합)

### 도메인 객체로서 절차(`process, procedure`)
- 비즈니스 로직상의 전략을 객체로 구분하는 전략패턴이 대표적인 방식
- 단순 로직 알고리즘이 아닌, 비즈니스 로직으로서의 전략을 의미

## Specification Pattern

> 암시적 개념을 구체화하는 패턴 중 하나

- 특정 도메인 엔티티는 도메인의 상태나 룰을 설명하는 메서드가 존재하기 마련(`isGoldMember()` 등등)
- 위와같은 메서드가 만약 복잡해지고, 상태 판별을 위해 본래 엔티티가 갖지 않는 책임이나 의존관계를 맺게 될 경우, 리팩토링이 필요
  - 만약 validate로직을 뜯어내어 응용계층으로 둘경우 결국 도메인에대한 검증과 룰을 응용계층에 노출하는셈이므로 좋은 설계라고 볼 수 없음
- 해당메서드들과 로직들을 명세(`specification`)이라는 VO로 분해
- 해당 패턴을 사용하면 VO로서 도메인의 룰은 도메인 계층에 존재하게되므로 보다 설계가 모델을 명확하게 반영

> specification 뿐 아니라, 묵시적인 개념으로서 `술어`에 해당하는 내용을 명시적인 VO로 표현하면 보다 명료한 설계가 될 수있음

### Specification 적용과 구현

#### 주요 목적
- 객체가 어떤 요건을 충족시키거나 특정 목적으로 사용할 수 있는지 가늠하고자 객체를 검증
- 컬렉션 내의 객체를 선택(기한이 만료된 송장 조회)
- 특정한 요구사항을 만족하는 새로운 객체의 생성을 명시

> 검증, 선택, 요청 구축

- validate 
- select
- building to order


#### validate

- `isSatisfiedBy() : boolean`

#### Specification Select 기법 - jpaSpecification 을 사용해보자
<img width="1043" alt="스크린샷 2022-08-20 오후 9 38 04" src="https://user-images.githubusercontent.com/85499582/185746577-4d51ab50-a55a-467d-a74a-b9db140871f5.png">
<img width="1017" alt="스크린샷 2022-08-20 오후 9 38 17" src="https://user-images.githubusercontent.com/85499582/185746574-d00bfc7c-5eaa-4f2a-bd87-acb415934def.png">

- https://groti.tistory.com/49

- 레포지토리에 명세를 넘겨 해당 명세를 만족하는 조회를 하는 기법으로, 단순 메서드쿼리나 qdsl을 통한 raw한 방식에 비해 객체지향적으로 원하는 리스트에 대한 조회조건을 캡슐화 가능


#### 요청 구축(생성, `building to order`)

- 명세에 충족하는 객체를 생성하는 패턴
- 혹은 이미 존재하는 객체가 명세에 맞게끔 변경되는것도 포함


### Specification 패턴은 현재 좋은패턴일까?

https://enterprisecraftsmanship.com/posts/specification-pattern-always-valid-domain-model/

- 위의 아티클에서는 생성시 검증을 하는 `Always-valid-domain-model` 패턴이 더 나은 방식이며  다만 객체 수정시에 specification을 사용하는건 추천

### 소고
- 해당 명세에 맞는 객체 생성방식은 나쁘지 않아 보임
- 또한 해당 객체가 명세를 계속 유지하고있는지에대해 검증하는 로직을 specificaion 객체가 들고있는것도 괜찮아보임
- 객체 생성시 `Always-valid-domain-model`에 해당하는 기본 validate는 객체의 abstract Specification의 validate에 존재하고 추가적으로 상속에 따라 템플릿패턴으로 구현하거나 데코레이터 패턴을 사용햇 validate를 추가하는 식으로 구현하면 될거같다.
- 또한 select은 굳이 필요한지 의문이들기도함
- 오히려 명세를 엔티티에 컬럼화하여 타입으로 조회하도록하면 보다 쉽지않을까 생각됨

# chapter 10. 유연한 설계
- 복잡하게 동작하는 소프트웨어에 좋은 설계가 걸여되면 리팩터링, 코드 결합이 점점 더 어려워짐
- 설계 요소가 모놀리식(모놀리스 아키텍처 의미x, DDD와 같이 도메인별 분리가 되어있지 않음을 의미)하게 구현되어있을경우 중복코드 양산의 위험성, 재사용과 코드 추적이 어려워짐 => 취약성
- 레거시 코드에 대한 중압감에 시달리지 않고 프로젝트 진행을 촉진하려면 변경을 수용하고 즐겁게 작업할수 있는 설계, 즉 `유연한 설계`가 필요
- chapter 9를 통해 묵시점 개념들을 심층 모델링화 하는데 성공했다면, 반복주기를 거쳐 핵심 관심사를 단순하고도 명확하게 표현하는 모델을 개발하고, 클라이언트 개발자가 모델을 실제 작동 가능한 코드로 만들어 낼수 있는 설계를 구현할 필요

![image](https://user-images.githubusercontent.com/85499582/185791905-83870ebf-ebd6-4750-b128-df288436a552.png)

## Intention-revealing interface(`의도를 드러내는 인터페이스`)

- 클라이언트 개발자는 기본적으로 설계된 도메인로직을 어플리케이션 계층의 조력객체들과 연동시키거나, 다른 도메인로직들과 결합시켜 보다 유즈케이스에 가까운 로직을 작성하는 역할
- 만약 클라이언트 개발자가 객체를 효과적으로 사용하는데 알아야할 정보를 인터페이스로부터 얻지 못한다면, 결국 세부적으로 코드를 파악해야하고, 이는 개발 생산성의 저하로 이어짐
- 도메인 내에 존재하는 개념을 클래스나 메서드의 형태로 명확하게 모델링하여 가치를 얻으려면 해당 도메인 개념을 반영하도록 크래스와 메서등의 이름을 지어야함!

> Kent Beck은 메서드의 목적을 효과적으로 전달하고자 `Intention-Revealing Selector` 를 사용해 메서드의 이름을 짓는 것을 주장

- 타입이름, 메서드 이름, 인자이름 셋이 조합되어 의도를 드러내는 인터페이스를 작성하는데 심혈을 기울이자
- 이때 이 이름들은 유비쿼터스 언어로 작성하며, 클라이언트 개발자의 관점에서 코드를 작성하기위해 BDD Test 코드로 명세를 만들면 보다 좋다.(켄트백 TDD)


## Side-Effect-Free-Function(`부수효과가 없는 함수`)
- 함수가 함수를 호출하고 그 함수가 다른함수를 또 호출하는식으로 무질서하게 중첩되면, 클라이언트 개발자가 의도하지 않았음에도 depth에 의해 부수효과가 발생할 확률이 높음
- 함수(`function`)은 부수효과를 동반하지 않기떄문에 함수라 부름
  - 중첩된 깊이를 걱정하지 않고도 다른함수를 호출홰야하며, 테스트하기도  쉬워야함

### 원칙
#### 명령과 질의(Command와 Query를 분리 - `CQS`)
- Command는 도메인 데이터를 반환하지 않아야하고, 가능한 한 단순하게 유지해야함
#### 연산의 결과를 표현하는 새로운 VO를 생성하여 반환하는 기법으로 생명주기에대한 걱정에서 멀어지기
- 만약 특정 command가 객체 필드의 특정 그룹들을 변화시킨다면, 해당 그룹들을 VO로 만들수 있는지, 그리고 VO에 책임을 할당할수 있는지 고민해보자
  
  
      public class Paint {
          private double volume;
          private int red;
          private int yellow;
          private int blue;
    
          public void mixIn(Paint otherPaint){
           ...
          }
      }
      // 위와같은 설계보단 아래와같이 VO의 로직으로 책임을 분리하여 새로운 VO가 반환케함으로서, 결론적으로 VO에 로직이 담겨 사이드 이펙트의 고민에서 떨어질 수 있게됨
      public class Paint {
          private double volume;
          private Color color;
    
          static public class Color{
             private int red;
             private int yellow;
             private int blue;
    
             public Color mixedWith(Color otherPaintColor, double ratio){
               ...
             }
          }
          public void mixIn(Paint otherPaint){
           ...
           double ratio = otherPaint.getVolume() / this.volume;
           this.color = this.color.mixedWith(otherPaint.getColor(), ratio);
          }
          
      }

> 변화할수없는 불변객체, VO에 책임을 할당함으로서, 변화로 인한 사이드이펙트의 가능성을 제거하여 훨씬 안전한 로직이 구현가능함이 핵심

## Assertion(`검증`)
- 테스트코드 작성시 Assertion으로 뭘 검증해야하는지 고민되는경우가 많다
- 연산의 사후 조건과 클래스 및 Aggregate의 불변식을 Assertion으로 검증해라!

## Conceptual Contour(`개념적 윤곽`)
- 설계요소를 응직력있는 단위로 분해하기
- 계속적인 리팩토링을 거쳐 변경되는 부분과 변경되지 않는 부분을 크게 나누고, 변경을 분리하기위한 패턴을 명확하게 표현하는 개념적 윤곽을 찾기

## StandAlone Class(독립형 클래스)
- high cohesion, low coupling을 명심하자
- 낮은 결합도는 인지부하를 낮춘다

## Closure of Operation(연산의 닫힘)
- 인자의 타입과 반환타입을 동일하게 하는 닫힌 연산 인터페이스구현은 해당 타입의 인스턴스 집합에 닫혀있는 고수준 인터페이스를 제공할 수 있다.
- 다만 이 방식은 VO의 로직에만 담도록하자
- Entity가 Entity를 연산으로 반환하는것은 일반적이진 않은 케이스


## 선언적 설계(추가 예정)
- specification 선언적 형식으로 확장해보기 예제 실습
- 지분계산 예시를 통해 유연한 설계해보기 예제 실습
