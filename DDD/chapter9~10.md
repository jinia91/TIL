# chapter 09. 암시적인 개념을 명확하게 - 모델은 도메인의 모든 개념을 최대한 구체적으로 보여줘야한다

## 심층적 모델링 : 개요

- 최초의 시작은 암시적인 개념을 임의의 정제되지 않은 형태로 인식하는것
- 반복적인 리팩토링과정을 거쳐, 성공적으로 개념에 할당된 책임을 조정하고 다른객체와의 관계를 변경하며 이름도 수정

## 개념 파헤치기
### 언어에 귀 기울여라
- 도메인 전문가가 사용하는 언어에 귀 기울여라.  
  - 복잡하게 뒤얽힌 개념들을 간결하게 표현하는 용어?
  - 도메인 전문가와 도메인에 대해 논의하며 기술적인 언어가 아닌, 도메인 언어를 사용하도록 하자

> `Ubiquitous Language`

- 언어, 문서, 모델 다이어그램, 코드에 모두 통용되는 통일된 언어를 사용해 소통하자
- 현재 작동되고 있는 어플리케이션에도 도메인상 핵심 개념이 묵시적으로 존재만 할뿐 모델로 정의되지 않은경우도 많다. 이를 구체화시켜 구현하면 훨씬 좋은 설계로 변경가능

### 어색한 부분을 조사하라
- 현재의 도메인 로직이 무언가 어색하게 느껴진다면 도메인 전문가와 적극적으로 소통하자

### 모순점에 대해 깊이 고민하라
- 도메인 로직과 실제와의 모든 모순을 해소하는것은 현실적이지도, 바람직하지도 않다.
- 그러나 모순되는 사항중 일부는 해결됬을때 더 나은 설계가 되기도한다.

### 서적을 참고해라
- 도메인에 관련된 책들을 읽자
- 바퀴를 다시 발명하지 말자

### 시도하고 또 시도하라
- 리팩터링을 반복적으로 수행하여 설계 품질 향상

## 다소 불명확한 개념을 모델링하는 법
- 때론 "발생" 과 같이 추사엊ㄱ인 개념도 객체 모델로 구성해야할 필요가 있음
- 일반적으론 "동사" 와 "명사" 를 조사해보자
- 하지만 이 외에도 중요한 범주의 개념이 존재할수 있음

### 명시적인 제약조건(`constraint`)
- 제약조건이 객체나 메서드 내에 포함되있는것보다 제약 조건을 별도의 메서드로 분리하는편이 좋음
  - validate or constrainedToCapacity

#### 별도의 제약조건, 검증, 정책 객체가 필요한상황
1. 만약 제약조건을 평가하기위해 본래 비즈니스로직상 필요한 객체의 정의, 책임에 적합하지 않은 데이터가 필요한경우
2. 관련 규칙이 여러객체에 걸쳐 나타나며, 동일한 계층구조에 속하지 않는 객체간에 중복 또는 상속관계를 요구

위와같은 상황이라면 제약조건을 명시적인 객체로 분리, 혹은 나아가 일련의 객체와 관계의 집합으로 모델링할수 있다.(validator 집합)

### 도메인 객체로서 절차(`process, procedure`)
- 비즈니스 로직상의 전략을 객체로 구분하는 전략패턴이 대표적인 방식
- 단순 로직 알고리즘이 아닌, 비즈니스 로직으로서의 전략을 의미

## Specification Pattern

> 암시적 개념을 구체화하는 패턴 중 하나

- 특정 도메인 엔티티는 도메인의 상태나 룰을 설명하는 메서드가 존재하기 마련(`isGoldMember()` 등등)
- 위와같은 메서드가 만약 복잡해지고, 상태 판별을 위해 본래 엔티티가 갖지 않는 책임이나 의존관계를 맺게 될 경우, 리팩토링이 필요
  - 만약 validate로직을 뜯어내어 응용계층으로 둘경우 결국 도메인에대한 검증과 룰을 응용계층에 노출하는셈이므로 좋은 설계라고 볼 수 없음
- 해당메서드들과 로직들을 명세(`specification`)이라는 VO로 분해
- 해당 패턴을 사용하면 VO로서 도메인의 룰은 도메인 계층에 존재하게되므로 보다 설계가 모델을 명확하게 반영

> specification 뿐 아니라, 묵시적인 개념으로서 `술어`에 해당하는 내용을 명시적인 VO로 표현하면 보다 명료한 설계가 될 수있음

### Specification 적용과 구현

#### 주요 목적
- 객체가 어떤 요건을 충족시키거나 특정 목적으로 사용할 수 있는지 가늠하고자 객체를 검증
- 컬렉션 내의 객체를 선택(기한이 만료된 송장 조회)
- 특정한 요구사항을 만족하는 새로운 객체의 생성을 명시

> 검증, 선택, 요청 구축

- validate 
- select
- building to order


#### validate

- `isSatisfiedBy() : boolean`

#### Specification Select 기법 - jpaSpecification 을 사용해보자
<img width="1043" alt="스크린샷 2022-08-20 오후 9 38 04" src="https://user-images.githubusercontent.com/85499582/185746577-4d51ab50-a55a-467d-a74a-b9db140871f5.png">
<img width="1017" alt="스크린샷 2022-08-20 오후 9 38 17" src="https://user-images.githubusercontent.com/85499582/185746574-d00bfc7c-5eaa-4f2a-bd87-acb415934def.png">

- https://groti.tistory.com/49

- 레포지토리에 명세를 넘겨 해당 명세를 만족하는 조회를 하는 기법으로, 단순 메서드쿼리나 qdsl을 통한 raw한 방식에 비해 객체지향적으로 원하는 리스트에 대한 조회조건을 캡슐화 가능


#### 요청 구축(생성, `building to order`)

- 명세에 충족하는 객체를 생성하는 패턴
- 혹은 이미 존재하는 객체가 명세에 맞게끔 변경되는것도 포함


### Specification 패턴은 현재 좋은패턴일까?

https://enterprisecraftsmanship.com/posts/specification-pattern-always-valid-domain-model/

- 위의 아티클에서는 생성시 검증을 하는 `Always-valid-domain-model` 패턴이 더 나은 방식이며  다만 객체 수정시에 specification을 사용하는건 추천

### 소고
- 해당 명세에 맞는 객체 생성방식은 나쁘지 않아 보임
- 또한 해당 객체가 명세를 계속 유지하고있는지에대해 검증하는 로직을 specificaion 객체가 들고있는것도 괜찮아보임
- 객체 생성시 `Always-valid-domain-model`에 해당하는 기본 validate는 객체의 abstract Specification의 validate에 존재하고 추가적으로 상속에 따라 템플릿패턴으로 구현하거나 데코레이터 패턴을 사용햇 validate를 추가하는 식으로 구현하면 될거같다.
- 또한 select은 굳이 필요한지 의문이들기도함
- 오히려 명세를 엔티티에 컬럼화하여 타입으로 조회하도록하면 보다 쉽지않을까 생각됨
