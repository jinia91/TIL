# chapter. 5
## 연관관계
### 연관관계를 쉽게 다루는 방법
1. 탐색 방향 부여
2. 한정자를 추가해 사실상 다중성을 감축
3. 중요하지 않은 연관관계 삭제

- 연관관계는 객체의 참조를 의미하고 의존성을 의미한다. 많은 의존성은 변화에 그만큼 열려있게 됨을 의미하므로 최소의 의존성만 갖는것이 설계관점에서 더 나은 스탠스
- 요구사항으로 엔티티간 서로 탐색을 해야하는 사항이 아니라면 양방향 연관관계는 지양하는게 더 남
  - e.g '게시물 -> 댓글은 일반적인 유즈케이스지만, 댓글 -> 게시물이 과연 일반적인 유즈케이스일까? 기획의 요구사항이 없다면 단방향이 더 나은 설계일것이며, 데이터 관점에서 참조를 위해서는 fk로 id만 갖는걸 생각해보자'

> 궁극적인 단순화는 연관관계를 완전히 제거하는것

### Entity
> 참조 객체라고도 함

객체의 본질은 `연속성과 식별성`

- 연속성 : 객체의 생명주기 내내 이어지는 추상적인 흐름
- 식별성 : 생명주기동안 객체의 고유함을 명시

식별성이 존재할때 해당 객체는 entity로 정의하며, 생명주기에 따라 온갖 속성이 다 바뀔수 있지만 그 식별성을 통해 연속성이 유지


#### 고유 id 소고

> 핵심은 식별성이며 사실상 실무에서 id값

=> id의 분산시스템에서 유일성을 위해 `snowflake` 방식 사용 Idgenerator

만약 db에서 id값을찍어준다면 해당 연산으로인한 lock, msa 관점이나 샤딩을 고려할때 결국은 개선해야할 부분

### VO

개념적 식별성보다는 사물의 특징을 묘사하는게 핵심인 객체

- 실무에서 간혹 사용되는 VO 컨벤션(엔티티 캡슐화를 위해 엔티티가 도메인계층밖으로 나갈때 래핑하는 개념)이랑은 비슷하나 다른 의미
  - DTO로서 VO는 불변성이 핵심이며, 필요에 따라 식별성을 갖지만 본책에서의 VO는 식별성을 가지지 않는 엔티티 내부의 primitive 타입을 도메인 타입으로 재정의하는 값객체로 이해
- 값객체는 기본적으로 불변성이 default지만 구현편의나 상황에따라 변경도 가능할 수 있음!



### Service 

> 도메인의 개념을 단순 사물로 설명하기 애매할때, 그 개념이 operation에 가까울때 사용하는 응용계층의 객체

- 도메인 엔티티와 도메인에 필요한 보조 객체들(helper나 validator, factory 등등 다양한 네이밍으로 존재)을 오케스트레이션하는 레이어
- 서비스계층은 어디까지나 오케스트레이션이며 로직은 srp 관점에서 내부 객체들에게 전가해야함
  - 핵심 비즈니스 로직은 도메인에

#### 소고

> 개인적으로 서비스가 서비스를 참조하는 방향성은 건전하지 못하다고 생각함
> 특정 유즈케이스/api를 위해 여러 서비스들이 조합되어야한다면 그 서비스의 public interface를 묶어 오케스트레이션하는 상위 facade를 정의하여 관리하는것이 더 나을듯

### Module

- 인지적 과부하를 줄이기위해 하나의 거대한 앱을 거시단위로 구분하는것
- 모델간 느슨한 결합도, 높은 응집도를 지향(high cohesion, low coupling)
- 본책의 DDD를 비롯, 애자일_msa_리액티브선언문_스프린트_tdd등 현대 소프트웨어공학에서 주창하는 다양한 이론들의 본질은 결국 유연한확장과 쉬운 유지보수를 위한 기민한 모듈을 만듬에 있음

#### 소고

본서에서는 레이어드 아키텍처를 통해 인프라 주도 설계, 데이터 중심 설계를 벗어나자고 말하지만 해당 방식은 한계가 존재하며, 핵사고날 아키텍처를 이용해 인프라스트럭처 주도의 패키징 구조를 벗어나, 도메인 중심의 패키징을 실현하고 아키텍처 - 코드 갭(architecture-code gap)을 감소시킴으로서 인지적 과부하를 줄이는 방향성이 보다 현대적인 트렌드


### 객체지향 패러다임을 통한 Model-Driven-Design

- 구현 패러다임을 도메인에 억지로 일치시키지않기
- 유비쿼터스 언어에 의존
- UML에 심취 x
- 항상 왜라는자세, 회의적으로 접근하자(?!)

# chapter. 6 도메인 객체의 생명주기

> 도메인 객체의 생명주기를 다룰때 주의할점
> - 무결성 유지
> - 생명주기 관리의 복잡성으로 모델이 난해해지는것을 방지하기

## Aggregate 패턴
> 소유권과 경계를 명확히 정의함으로써 모델을 엄격하게 만들어 객체간의 연관관계가 혼란스럽게 얽히지 않게하기, 도메인 객체의 무결성 유지하는데 매우 중요

### 화두) 객체의 생성과 변경의 경계를 어디까지로 정할것인가?

모델 내에서 복잡한 연관관계를 맺는 객체를 대상으로 변경의 일관성을 보장하기란 쉽지않고, DB차원에서 제약조건이나 트랜잭션을 통해 이를 묶어두더라도, 이는 임시방편적인 해법이며 모델에 집중하느것을 방해, 
모델주도, 도메인 주도의 설계라고 볼 수 없다.

결국은 모델의 경계 정의가 중요, 모델을 근간으로 하는 해법을 이용하자!

### 모델 주도 설계 접근법

- 모델 내의 참조에 대한 캡슐화를 추상화하기
- AGGREGATE에는 root와 boundary가 존재하며, 루트는 단 하나, AGGREGATE에 포함된 특정 Entity를 지목, AGGREGATE안의 객체들은 서로 참조 가능하지만, 외부에서는 root로만 참조가능하고, 루트 이외의 Entity는 지역 식별성을 가지며 이는 AGGREGATE안에서만 구분 가능

#### Rule
- 루트 Entity는 전역 식별성을 지니며, 궁극적으로 불변식을 검사할 책임이 있다
- 루트 Entity는 내부 Entity에 대한 참조를 다른 객체에 전달해 줄수는 있지만, 그러한 객체는 전달받은 참조를 일시적으로만 사용할수 있고(지역변수로만 가능, 클래스, 인스턴스 변수로는 가지고 있으면 안됨) 참조를 계속 보유할 수 없음. 루트는 VO의 복사본을 다른 객체에 전달해 줄수 있으며, 복사본에서는 무슨일이 일어나든 문제되지않음, 왜냐면 단순 복사본이니까
- DB를 통해 Root만 직접 획득 가능하고, 다른 VO, 엔티티들은 Root를 통해서 탐색하여 발견해야함
- AGGREGATE 패턴의 강점은 root 만 삭제하더라도 내부 ENtity의 참조가 다 끊기므로 GC를 통해 효율적인 메모리관리가 가능한 컨벤션 구축이 가능

### tip

이커머스에서 order_item 과 item은 연관관계를 맺을수는 있지만, 가격이나 일정 정보는 order_item이 독립적으로 데이터를 가지고있어야함!, 만약 중간에 가격이 변동되는경우 주문완료나, 주문중인 아이템의 가격이 변동되는 문제등이 발생할수 있음

## Factory Pattern

복잡한 객체, Aggregate를 생성할때 이를 캡슐화시켜주는 생성 객체 정의하기

- 클라이언트에서 객체를 생성하는것은 가장 나쁜 패턴
- 복잡한 객체의 생성이 해당 객체를 생성됬을떄 하는 일과 관련성이 과연 있을까?

복잡한 객체와 Aggregate의 인스턴스를 생성하는 책임을 별도의 객체로 옮기고, 이 객체자체는 도메인 모델에서 아무런 책임도 맡지 않을수도 있지만, 여전히 도메인 설계의 일부를 구성

- 그렇다면 factory method 패턴 vs builder vs factory 패턴 어떤것이 더 좋은가?

  - 상황에 따라 다름
  - 각 생성방법은 원자적이어야 하며, 불변식이 지켜져야함
  - Factory는 생성된 클래스보다 생성하고자 하는 타입으로 추상화되야함

- factory는 해당 factory에서 만들어내느 객체와 매우 강하게 결합되있으므로, 가장 밀접한 관계에 있는 객체에 있어야함


### 생성자만으로 충분한 경우도 있음
- 클래스가 타입인 경우 클래스가 어떤 계층구조의 일부를 구성하지 않으며, ㅇ니터페이스를 구현하는식으로 다형적으로 사용되지 않는경우
- 클라이언트가 strategy 를 선택하는 한 방법으로서 구현체에 관심이 있는경우
- 클라이언트가 객체의 속성을 모두 이용할 수 있어서 클라이언트에게 노출된 생성자 내에서 객체 생성이 중첩되지않는경우
- 생성자가 복잡x
- 다른 클래스의 생성자에서 생성자를 호출하는경우는 안좋은 패턴! 생성자는 극도로 단순해야한다!
  - 다른 참조 객체의 생성은 factory에서 이루어지는게 맞으며, 생성자 내에서 다른 생성자가 호출되는것은 안된다!

### 인터페이스 설계
- 각 연산은 원자적
- Factory는 자신에게 전달된 인자와 결합될 것이다
- 넘겨줄 인자는 하위 설계 계층에서 나오는 매개변수가 가장 안전

## Repository

> DB에 저장되어있는 data를 객체로 만드는 구조물

- 저장된 객체를 가져오는것은 실제로는 생성의 한 부분집합, 하지만 새로생성되는것이 아닌 식별성을 유지한채로 재구성하는것
- 도메인 주도설계의 목표는 기술보다는 도메인에 대한 모델에 집중해 더 나은 소프트웨어를 만들어 내는것이며, infra에 대한 관심을 덜할수록 좋다! 따라서 그 책임을 repository에서 대신해주는것

> 현재는 레포지토리에 대한 많은 개념들이 JPA Repository impl 을 통해 프레임워크차원에서 구현이 되어있다. 덕분에 개발자들은 RDB, noSQL 등의 infra에 들어있는 데이터를 -> 객체화 시키는데 복잡한 기술적 코드, 매핑코드, 식별성등을 고려하지 않고도 객체의 저장과 불러오기가 가능해졌고, 보다 비즈니스 로직, 도메인 로직에 집중할수 있게되었음!

### Factory와 Repository 관계

- 객체의 생명주기 초기단계를 다루는 factory와 달리 repository는 객체의 중간단계와 마지막 단계를 관리하는데 도움이됨
- factory는 새로운 식별 엔티티를 만들어내는 반면, repository는 이미 식별자를 가진 엔티티를 불러내는 책임







