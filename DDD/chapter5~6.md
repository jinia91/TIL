# chapter. 3
## 연관관계
### 연관관계를 쉽게 다루는 방법
1. 탐색 방향 부여
2. 한정자를 추가해 사실상 다중성을 감축
3. 중요하지 않은 연관관계 삭제

- 연관관계는 객체의 참조를 의미하고 의존성을 의미한다. 많은 의존성은 변화에 그만큼 열려있게 됨을 의미하므로 최소의 의존성만 갖는것이 설계관점에서 더 나은 스탠스
- 요구사항으로 엔티티간 서로 탐색을 해야하는 사항이 아니라면 양방향 연관관계는 지양하는게 더 남
  - e.g '게시물 -> 댓글은 일반적인 유즈케이스지만, 댓글 -> 게시물이 과연 일반적인 유즈케이스일까? 기획의 요구사항이 없다면 단방향이 더 나은 설계일것이며, 데이터 관점에서 참조를 위해서는 fk로 id만 갖는걸 생각해보자'

> 궁극적인 단순화는 연관관계를 완전히 제거하는것

### Entity
> 참조 객체라고도 함

객체의 본질은 `연속성과 식별성`

- 연속성 : 객체의 생명주기 내내 이어지는 추상적인 흐름
- 식별성 : 생명주기동안 객체의 고유함을 명시

식별성이 존재할때 해당 객체는 entity로 정의하며, 생명주기에 따라 온갖 속성이 다 바뀔수 있지만 그 식별성을 통해 연속성이 유지


#### 고유 id 소고

> 핵심은 식별성이며 사실상 실무에서 id값

=> id의 분산시스템에서 유일성을 위해 `snowflake` 방식 사용 Idgenerator

만약 db에서 id값을찍어준다면 해당 연산으로인한 lock, msa 관점이나 샤딩을 고려할때 결국은 개선해야할 부분

### VO

개념적 식별성보다는 사물의 특징을 묘사하는게 핵심인 객체

- 실무에서 간혹 사용되는 VO 컨벤션(엔티티 캡슐화를 위해 엔티티가 도메인계층밖으로 나갈때 래핑하는 개념)이랑은 비슷하나 다른 의미
  - DTO로서 VO는 불변성이 핵심이며, 필요에 따라 식별성을 갖지만 본책에서의 VO는 식별성을 가지지 않는 엔티티 내부의 primitive 타입을 도메인 타입으로 재정의하는 값객체로 이해
- 값객체는 기본적으로 불변성이 default지만 구현편의나 상황에따라 변경도 가능할 수 있음!



### Service 

> 도메인의 개념을 단순 사물로 설명하기 애매할때, 그 개념이 operation에 가까울때 사용하는 응용계층의 객체

- 도메인 엔티티와 도메인에 필요한 보조 객체들(helper나 validator, factory 등등 다양한 네이밍으로 존재)을 오케스트레이션하는 레이어
- 서비스계층은 어디까지나 오케스트레이션이며 로직은 srp 관점에서 내부 객체들에게 전가해야함
  - 핵심 비즈니스 로직은 도메인에

> 개인적으로 서비스가 서비스를 참조하는 방향성은 건전하지 못하다고 생각함
> 특정 유즈케이스/api를 위해 여러 서비스들이 조합되어야한다면 그 서비스의 public interface를 묶어 오케스트레이션하는 상위 facade를 정의하여 관리하는것이 더 나을듯

### Module

- 인지적 과부하를 줄이기위해 하나의 거대한 앱을 거시단위로 구분하는것
- 모델간 느슨한 결합도, 높은 응집도를 지향(high cohesion, low coupling)
- 본책의 DDD를 비롯, 애자일_msa_리액티브선언문_스프린트_tdd등 현대 소프트웨어공학에서 주창하는 다양한 이론들의 본질은 결국 유연한확장과 쉬운 유지보수를 위한 기민한 모듈을 만듬에 있음

=> 본서에서는 레이어드 아키텍처를 통해 인프라 주도 설계, 데이터 중심 설계를 벗어나자고 말하지만 해당 방식은 한계가 존재하며, 핵사고날 패키지를 이용해 인프라스트럭처 주도의 패키징 구조를 벗어나, 도메인 중심의 패키징을 실현하고 아키텍처 - 코드 갭(architecture-code gap)을 감소시킴으로서 인지적 과부하를 줄이는 방향성이 보다 현대적인 트렌드


### 객체지향 패러다임을 통한 Model-Driven-Design

- 구현 패러다임을 도메인에 억지로 일치시키지않기
- 유비쿼터스 언어에 의존
- UML에 심취 x
- 항상 왜라는자세, 회의적으로 접근하자(?!)




