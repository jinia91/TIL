# 리팩토링?

> 소프트웨어의 겉보기 동작은 그대로 유지한 채, 코드를 이해하고 수정하기 쉽도록 내부 구조를 변경하는 기법

- why : 이해하고 수정하기 쉬운코드
- what : 내부 구조를 변경
- how : 겉보기 동작은 그대로 유지한 채
- 
- <img width="705" alt="스크린샷 2022-11-13 오후 8 42 29" src="https://user-images.githubusercontent.com/85499582/201519910-3f896c94-7a4a-466c-8b65-9b435d5aec3b.png">

=> 마틴파울러가 정의한 협의의 리팩터링은 스펙으로서 public interface는 동일하며 내부 구현이 변경되는 수준이고 spec을 재정의하면 리스트럭처링이라고 함

## 리팩토링과 기능변경 추가에대해 pr tip!
- 리팩토링시엔 테스트도 수정하지 말것!
- 리팩토링코드와 기능추가변경이 같이 병행되면 pr을 알아보기 힘들어진다.(실제 실무에서 리팩토링과 기능 변경 추가가 병행되니 diff파일이 60개가 넘어가고 코드리뷰가 매우 힘들어짐 ...ㅠㅠ)
- 리팩털이 커밋과 기능추가 커밋을 분리하자

## 리팩토링 왜하는가?

- 소프트웨어 설계가 좋아짐
- 이해하기 쉬워짐
- 버그찾기 쉬워짐

= > 예측가능한 구조, 개발자가 이해하기쉬운 코드 => 프로그래밍속도 향상, 결과적인 생산성향상

> 소프트웨어의 지구력!

## 언제 리팩토링하지? 현실적으로...

- 기능을 쉽게 추가하기 위한 리팩토링 : `기능 추가`전 확장이 용이한 구조로바꾸기
- 이해하기 쉬운 코드 : `클린코드`로 바꾸는 리팩토링
- 쓰레기줍기 리팩토링 : `비효율적으로 동작`하는 쓰레기코드 바꾸기 
- `코드리뷰할때` 남의코드 수정사항 제안 : 이것도 리팩토링이다!

> 코드가 지저분하더라도 굳이 수정할 필요가 없다면, 차라리 새로 작성하는게 쉬울경우 : 차라리 리팩토링하지말자

## YAGNI
> 코딩을 시작하기 전에 아키텍처를 확정하고 유연한 메커니즘, 유연한 확장을 고려한 개발?
- 현실적으로 아키텍처를 확정할수 있을만큼 요구사항을 사전에 확실히 판단가능할까? 되려 대응 능력이 저해되는 경직된 아키텍처를 만드는것은 아닌가? 오버아키텍처링아닐까? 생산성 저하?

### you are not going to need it
1. 추측하지 말고 현재 요구사항만 충족해! 더도말고 딱!
2. 대신 그것을 최대한 멋지게 해결하도록 설계해!
3. 나중에 더 잘 이해하게 되면 그때 리팩터링해!

모르는걸 대비해서 선제적 아키텍처를 설계하기보다는, 도메인을 이해한 수준만큼만 반영하는것이 생산적이고 효율적!
> 확실히 체감되는말로, 굳이 오버아키텍처링, 차력쇼하는게 의미가 있을까?


## 리팩터링과 성능

- 직관적 설계 vs 성능
  - 리팩터링은 이해하기 쉬운 코드를 위해 `속도가 느려지는` 방향으로 코드를 짜게될 확률이 높다.
  - 클래스를 쪼개면서 인스턴스를 새로 생성하게되는 오버헤드
  - 가독성과 cqs를 위해 시간복잡도 o(N)인 함수를 두개로 쪼개 o(2N)으로 만든다던가

### 패러다임을 바꿔 생각하자
- 성능문제는 자잘한 함수들의 추가때문에 발생하는것이 아니다.
- 대부분의 성능문제는 하나의 특정 코드가 문제되는경우가 많다.
- 보기좋게 리팩토링된 코드는 **그 하나의 특정 코드**를 발견하기 쉽게하고, 변경하기도 쉽게한다.

=> 리팩터링이 잘된 코드는 `성능 분석` 에 유리하다

# 소고 정리

## public interface
public interface : client 코드 소유권이 없는 상황, endpoint거나 공통 모듈 또는 현 프로젝트의 의존성을 갖는 모듈이 존재하는경우
  - 마틴 파울러는 엄격한 코드 소유권 분리는 비효율성을 낳는다고 주장, 구글의 mono repo multi project같은 케이스가 비슷한 방향성이 아닐까?


## 브랜치 전략
- CI의 핵심은 잦은 pull, 최소 하루 한번
- git flow 전략처럼 release와 dev 브랜치를 이중으로 관리할경우 여기서 강점이 드러나는데, 미완성의 feature 브랜치라도 기능이 어느정도 완성됬을때 dev 브랜치로 빠르게 통합하여 큰 diff를 줄일수 있음
- 만약 github 전략처럼 feature => master == release일경우 불완전한 feature의 통합이 불가능하므로 매feature가 merge될때마다 큰 diff를 발생할 수 밖에 없음

## 성능은 측정해라
- 프로파일러등을 이용해서 성능측정을 하고 그 결과를 기반으로 개선하자
- 막연히 이럴것이다라는 추측으로 접근하는건 비효울적
  - 성능에 지장이 있을거라 생각하는 로직의 대다수는 사실 전체 성능 저하에 큰 영향을 끼치지 않는경우가 많다.
  - 오히려 이런 코드들이 명시적으로 잘 보이도록 가독성있는 리팩토링을 해두는게, 차후 성능테스트의 피드백을 하기에 더 좋다
  - 즉 성능을 신경쓰지 말고 가독성을 신경써서 코드를 자다가 성능에 문제가 생기면 그때 프로파일링후 개선하자! 


