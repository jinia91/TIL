# Collections

<img width="680" alt="스크린샷 2022-08-31 오전 12 31 57" src="https://user-images.githubusercontent.com/85499582/187478817-3e83599d-fa77-4056-91f1-e4f33bd1c2cf.png">


## 표준 라이브러리 사용

### Immutable List

    val immutableList = list.of("a", "b", "c")
    
불변 list

### mutale List

    val mutableList = mutableListOf<String>()
    
    mutableList.add("a")
    mutableList.add("b")
    mutableList.add("c")
    
  
    val mutableList2 = mutableListOf<String>().apply {
    add("a")
    add("b")
    add("c")
    }
    
    
### Set 도 동일
<img width="486" alt="스크린샷 2022-08-31 오전 12 36 28" src="https://user-images.githubusercontent.com/85499582/187479844-569f44ca-f5ef-4ac6-bfb4-91bac483defa.png">

### Map
<img width="383" alt="스크린샷 2022-08-31 오전 12 37 29" src="https://user-images.githubusercontent.com/85499582/187480067-01aa8e82-b7d8-4d6f-9c72-f6d9bc51311d.png">

- `[]`로 사용을 더 선호

### 컬렉션 빌더

<img width="441" alt="스크린샷 2022-08-31 오전 12 38 59" src="https://user-images.githubusercontent.com/85499582/187480386-d03e4415-19d2-4e25-9b7a-9484a8a65fbd.png">

- 빌더패턴을 사용해 리스트 생성 가능하며, 빌더 내에서는 뮤터블하나 반환되는 타입은 일반 `List`타입으로 immutable하게 반환됨
- 빌더패턴의 특성상 최종 반환하기 전까지 체이닝됨을 생각하면 이해하기쉽다


### for-each 등과같은 컬렉션 인라인함수들

<img width="273" alt="스크린샷 2022-08-31 오전 12 42 33" src="https://user-images.githubusercontent.com/85499582/187481154-3c9e602c-db9a-4342-b299-73035aa384e4.png">


- 자바 스트림과 달리 종단 연산자 없이 그냥 사용 가능하며 asSequence()라는 별도의 api가 자바 스트림과 유사
- https://junyoung-developer.tistory.com/103
- 컬렉션 인라인함수는 내부적으로 매번 종단연산을 하므로 매번 객체를 생산하게되며 이는 오버헤드
- 체이닝이 많이 걸리거나, 다룰 데이터가 많은 상황이라면 시퀸스를 통해 지연시키고 종단연산으로 객체 생성하는게 옳다
- 5만건 10만건 이하정도라면 컬렉션 인라인 함수를 쓰는게 더 낫다함


# 데이터 클래스
- dto 로 사용되는 단순 클래스 자동정의
- hashcode equals toString copy component 메서드 자동생성
- 사실상 롬복 기본탑재

## `==`, `===`
자바와는 달리 자스처럼 동등연산은 `==`, 동일 연산은 `===`

## copy
- 불변 객체 복사시 사용

## Component
- 구조분해 할당에 사용

# 싱글턴
> 클래스의 인스턴스를 하나의 단일 인스턴스로 제한하는 디자인 패턴

## java 에서

### DCL(double check Locking)
- https://velog.io/@cchloe2311/%EB%94%94%EC%9E%90%EC%9D%B8%ED%8C%A8%ED%84%B4-Singleton-Pattern-%EC%8B%B1%EA%B8%80%ED%86%A4-%ED%8C%A8%ED%84%B4


### Enum 싱글턴
- 이펙티브 자바에서 제안한 방식
- 실무에선 잘 안보임

### 이른 초기화

`static final` 로 초기화 후 `getInstance`로 반환

### 지연초기화

첫 호출시 생성, 동시성 이슈때문에 `syncronize` 키워드 사용시 성능 저하

## 코틀린에서
- 언어차원에서 지원
### `Object` 키워드
- utils 또는 helper 클래스 작성시 주로 사용

### 동반객체 `companion object`
- https://www.bsidesoft.com/8187
- 클래스 내부에 존재하는 특수한 object
- 클래스의 인스턴스를 생성하지 않아도 싱글턴 인스턴스로 존재하므로 static 과 동일한 역할 수행 가능, 코틀린은 static이 없다!

# sealed class
 - https://kotlinworld.com/165

- 추상 클래스로 상속받는 자식 클래스의 종류를 제한하는 키워드
- 컴파일러가 sealed class의 자식 클래스가 어떤것이 있는지 알 수 있다.
- 같은 패키지에서만 상속 가능, 모듈도 가능?
- 기본적으로 abstract 이므로 인스턴스 생성 불가

# 확장함수

- 데코레이터 패턴을 언어차원에서 지원한다고 생각하면 됨

        fun String.first() : char {
        return this[0]
        }
        
 - 위와같이 함수를 확장하여 사용 가능
 - 동일 시그니처 메스드명으로 확장하는 경우 원본 함수가 우선순위

# 제네릭

- PECS producer-extends, consumer - super
- 공변성은 자바 제네릭 extends, 코틀린에선 out
- 반공변성은 자바 제네릭 super, 코틀린에선 in

# 지연 초기화

- val by lazy {}
    - 멀티스레드에 세이프(sncronized)
- lateinit var

