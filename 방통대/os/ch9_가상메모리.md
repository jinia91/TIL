# 가상 메모리의 개념
> 메모리 크기보다 더 큰 기억공간이 필요한 프로세스도 실행할 수 있게 하는 방법

- 실행중인 프로세스에 의해 참조되는 주소를 메모리에서 사용하는 주소와 분리

프로세스가 직접 참조하는 주소 == 가상주소공간
실 메모리상에서 사용가능한 공간 == 실주소공간

- 이때 가상주소를 cpu에서는 실주소로 써야하므로 매핑(사상)이 필요!

- 가상주소공간은 보조기억장치에 저장

## 사상(mapping)
> 프로세스 실행을 위해 가상주소를 실주소로 변환하는 과정
- 동적 주소변환(DAT): 프로세스가 실행되는 동안 매핑되어야함

- 인위적 연속성 : 가상주소공간에서 연속적인 주소가 실주소 공간에서도 연속적일 필요는 없음

## 주소변환
- 주소변환 사상표 : 동적주소변환을 위한 정보를 가진 표
- 단위가 너무 작으면 비효율적이므로, 블록단위로 주소변환함

### 블록사상시스템
- 블록단위로 주소변환
- 가상메모리의 각 블록이 메모리의 어디에 위치하는지 관리

### 블록구성방식
- 페이지(page) : 블록의 크기가 동일
- 세그먼트(segment) : 블록의 크기가 다 다를수 있을때

### 페이징기법
- 가상 메모리를 페이지 단위로 나누어 관리하는 기법
- 메모리 영역도 페이지와 동일한 크기의 페이지 프레임으로 나눔

<img width="518" alt="image" src="https://github.com/jinia91/TIL/assets/85499582/776e9a89-199a-40f4-8e47-c0f814a7c94d">

- 직접사상에 의한 동적 주소변환 : 페이지 사상표를 직접 이용
- 연관사상에 의한 동적 주소변환 : 페이지 변환 정보를 연관 메모리에 저장한 연관사상표를 이용

### 페이징기법 특징
- 논리적 의미와 무관한 동일크기의 페이지로 나눔
- 메모리 보호는 페이지 단위로 이루어짐
- 외부 단편화는 발생하지 않으나 내부 단편화는 발생가능

### 세그먼테이션 기법
- 가상 메모리를 세그먼트 단위로 나누어 관리하는 기법
<img width="566" alt="image" src="https://github.com/jinia91/TIL/assets/85499582/b93efc3f-83cd-48d6-a7aa-c3183c86b934">

- 세그먼트이므로 길이도 저장해야함


### 페이징/세그먼테이션 혼용기법
- 가상메모리를 세그먼트 단위로 분할후 각 세그먼트를 다시 페이지 단위로 분할

# 메모리 호출 기법
> 어느시점에 페이지 또는 세그먼트를 메모리에 적재할 것인가?
- 요구페이지 호출기법 : 필요할때 - 프로세스 시작 시점에는 연속적으로 페이지 부재 발생
- 예상페이지 호출기법 : 예상해서 - 예상연산을 위한 오버헤드 필요, 예상이 잘못되면 낭비


