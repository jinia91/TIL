# 스케줄링

## 프로세스 스케줄링

- 스케줄링
  - 여러가지 작업의 처리순서를 결정
  - ex) 프로세스 스케줄링, 디스크 스케줄링 등

- 프로세스 스케줄링
  - 주어진 프로세스가 여러개인 경우, 프로세스 처리 순서를 결정하는 것

## 스케줄링 단계

<img width="753" alt="image" src="https://user-images.githubusercontent.com/85499582/227711140-06ed2ee0-e711-41ca-a9e7-0ef573ff4b5f.png">

### 상위단계 스케줄링
작업이 작업큐에 최초에 들어오면 이를 스케줄링이 가능한 프로세스로 만드는 역할
- 시스템의 자원을 효율적으로 이용할 수 있도록 함

### 중간단계 스케줄링
- 시스템에 대한 단기적인 부하 조절을 위해 일부 프로세스를 일시 중지시키는 역할

### 활성화된 작업들(프로세스들)을 스케줄링(하위단계 스케줄링)
- 일반적인 프로세스 스케줄링
- 준비큐에 있는 프로세스를 선택하여 사용가능한 CPU를 할당(디스패치)하는 역할
- 수행주체 : 디스패처(dispatcher)



## 스케줄링 기본 목표
- 공정성
  - 모든 프로세스가 적정 수준에서 CPU작업을 할 수 있게 함
- 균형
  - 시스템 자원이 충분히 활용될 수 있게 함

### 운영체제의 유옇에 따른 스케줄링 목표
1. 일괄처리 운영체제

- 처리량의 극대화 : 주어진 시간에 처리한 프로세스 수
- 반환시간의 최소화 
  - 반환시간 : 프로세스 생성 ~ 종료 시점까지의 소요시간
- CPU활용의 극대화


2. 시분할 운영체제

- 빠른 응답시간 : 요청한 시점부터 반응이 시작되는 시점까지 소요시간(첫 로드뜨기까지로 이해하면 편함)
- 과다한 대기시간 방지 : 프로세스가 종료될 때 까지 준비큐에서 기다린 시간의 합

3. 실시간 운영체제

- 처리기한 맞춤

## 스케줄링 정책
> 스케줄링의 목표에 따라 우선적으로 고려해야할 기본적인 정책

### 선점(preemptive) 스케줄링 정책
- 실행중인 프로세스에 인터럽트를 걸고 다른 프로세스에 CPU를 할당할 수 있는 스케줄링 방식
- 높은 우선순위의 프로세스를 우선 처리해야 하는 경우에 유용
  - 실시간 시스템, 시분할 시스템
- 컨텍스트 스위칭에 따른 오버헤드가 발생!
  - 컨텍스트 : CPU의 모든 레지스터와 기타 운여에제에 따라 요구되는 프로세스의 상태
  - 컨텍스트 스위칭 : CPU가 현재 실행하고 있는 프로세스의 문맥을 PCB에 저장하고 다른 프로세스의 PCB로부터 문맥을 복원하는 작업(레지스터 읽기)
-> 컨텍스트 스위칭이 매우빠르게 이루어지도록 만들어져야함

### 비선점(nonpreemptive) 스케줄링 정책
- 실행 중인 프로세스를 바로 준비상태로 전이시킬 수 없는 스케줄링 방식
- CPU를 할당받아 실행이 시작된 프로세스는 대기상태나 종료상태로 전이될 때까지 계속 실행상태에 있게 됨
- 강제적인 문맥교환이 없어 오버헤드 발생하지 않음(자발적 컨텍스트 스위칭은 가능하긴함)
- 긴 프로세스가 실행중이라면 짧은 프로세스가 오래 기다리게 되는 경우 발생


## 스케줄링의 평가 기준
- 평균 대기 시간
  - 각 프로세스가 수행이 완료될 때까지 준비 큐에서 기다리는 시간의 합의 평균값

- 평균 반환 시간
  - 각 프로세스가 생성된 시점부터 수행이 완료된 시점까지의 소요시간의 평균값


## 스케줄링 알고리즘

### FCFS 스케줄링(First come First served) fifo
- 비선점 방식
- FIFO 큐
- 가장 기본적인 스케줄링기업
- 짧은 프로세스가 긴 프로세스를 하염없이 기다리거나, 중요한 프로세스도 나중에 수행될 수 있음
- 시분할, 실시간 운영체제에선 부적합
- 도착순서가 다를경우 평균대기 평균 반환시간이 다름

### SJF(Shortest Job First)
- 비선점방식
- 준비큐에서 기다리는 프로세스중 실행기간이 가장 짧다 예상되는 작업순으로 실행
- 일괄처리환경에서 구현하기 쉬움
- 실제로는 먼저 처리할 프로세쓰의 처리시간예상이 어려움
- 새로들어온 짧은 프로세스가 먼저처리되거나, 중요한 프로세스가 나중에 수행될 수도 있음
- 시분할, 실시간 운영체제에는 부적합

### SRT(shortest Remaining Time)
- 선점방식
- SJF를 선점방식으로 적용
- SJF보다 평균대기시간, 평균반환시간이 효율적
- 실제로는 프로세스의 CPU 예상시간 파악 어려움
- 각 프로세스의 실행시간 추적, 선점을 위한 문맥교환등 SJF보다 오버헤드가 큼


### RR(Round-Robin)
- 선점방식
- 준비큐에 도착한 순서대로 디스패치하지만, 정해진 시간할당량에 의해 실행 제한
- 시간 할당량 안에 종료하지 못한 프로세스는 준비큐의 마지막에 배치됨
- CPU 독점하지 않고 공평하게 이용 
  - 시분할 운영체제에 적합
- 시간 할당량이 너무 크면 FCFS랑 동일하고, 시간할당량이 너무 작으면 너무 많은 문맥교환이 발생하므로 오버헤드가 커짐

### HRN(Highest Response Ratio Next)
- 비선점방식
- 준비큐에서 기다리는 프로세스중 응답비율이 가장 큰 것을 먼저 디스패치
 <img width="674" alt="스크린샷 2023-03-25 오후 7 43 38" src="https://user-images.githubusercontent.com/85499582/227712430-72d7cf8c-7f03-4d9e-8ed1-b02d084cae7f.png">

- SJF 스케줄링의 단점을 보완
- 예상실행시간이 긴 프로세스도 오래대기하면 응답비율이 커져 나중에 들어오는 짧은 프로세스보다 먼저 디스패치 가능
- 실제 프로세스의 CPU 시간을 예상하긴 힘듬

### 다단계 피드백 큐 스케줄링
- 선점방식
- I/O중심 프로세스와 연산 중심 프로세스의 특성에 따라 서로 다른 시간 할당량 부여
- 단계 1 부터 단계 N까지 하나씩의 준비큐 존재
- 단계 K는 단계 K+1에 피드백
- 단계가 커질수록 시간 할당량도 커짐
