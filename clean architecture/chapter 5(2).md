# 클린아키텍처에서 말하는 아키텍처 구성 요소
## 엔티티 
> 핵심 업무 데이터를 기반으로 동작하는 일련의 조그만 핵심 업무 규칙 구현 객체
- 핵심 업무 데이털를 직접 포함하거나 쉽게 접근 가능
- 핵심 업무 데이터를 기반으로 동작하는 핵심 업무 규칙을 구현한 함수들로 구성
- Critical Business Rule Data + Critical Business Rule == Entity

## 유즈케이스
- 자동화된 시스템이 사용되는 방법을 설명하는것
- 사용자가 제공해야하는 Input, OutPut, OutPut출력을 위한 처리 단계를 기술
- 애플리케이션에 특화된 업무규칙을 설명

        <<대출을 위한 서류 제출 간략 예시>>
        Input : 이름, 주소, 생일 주번, 핸폰번호등
        Output : 사용자 확인을 위한 동일한 정보 + 신용도
        - Process
        1. 이름 검증
        2. 주소 생일 운전면허번호 주민번호 검증
        3. 위의 데이터를 가지고 신용도를 CB사에서 얻어옴 
        4. 신용도가 500보다 낮으면 Deny
        5. 높으면 Customer를 생성하고 LoanApp(Loan Estimation)생성

- 유즈케이스는 엔티티를 어떻게 제어할지를 정의
- 인터페이스로 들어오는 데이터와 인터페이스에서 되돌려주는 데이터를 형식 없이 명시한다는점만 제외하면, 사용자 인터페이스를 기술하지 않는다는점
- 유즈케이스도 객체
- 이때 엔티티는 자신을 제어하는 유즈케이스에대해 절대 알지 못한다! 의존성 방향의 문제를 생각해봐라
  - 고수준의 개념은 저수준의 개념에대해 알필요없음, 알지도 못함

## 요청 및 응답모델
- 사용자 인터페이스를 통해 유즈케이스의 Input을 만들어내고 Output을 가공하여 사용자 인터페이스로 제공하는 역할
- 엔티티 객체를 가리키는 참조를 요청 및 응답 데이터구조(e.g HttpReqeust, HttpResponse)에 포함하는것은 안티패턴
  - 장기적으론 Tramp Data와 수많은, 불필요한 조건문을낳게됨!

# 소리치는 아키텍처
> 핵심은 소프르웨어 아키텍처를 딱 보았을때, 아키텍처가 애플리케이션의 유스케이스를 소리쳐야한다는것

- 아키텍처는 실무에서 모듈이거나 패키지일텐데 이것만 보았을때, 애플리케이션이 무엇을 하는 애플리케이션인지를 파악할 수 있어야지, 무슨 프레임워크, 무슨 기술, 무슨언어인지가 눈에 들어오면 안됨
- 좋은 아키텍처는 항상 유즈케이슬르 그 중심에 둔다.
- 저자는 엔티티 객체는 순수 POJO여야하며, 프레임워크가 침투해서는 안된다고 주장

![image](https://user-images.githubusercontent.com/85499582/221603067-f9c858fc-7a10-40ba-9545-9cf529d61434.png)

- DIP를 사용해 의존성 방향 제어하기

## 경계를 횡단하는 데이터의 형태 간략예시

![image](https://user-images.githubusercontent.com/85499582/221605211-16d54343-a4da-42ed-aefd-b1beafcb1713.png)

1. Entity

- 순수 Entity만 존재

2. Application 

- 1. Entity를 조작하는 UseCaseInteractor : Service
- 2. DataAccessInterface : DrivenPort(e.g repository, client, gateway)
- 3. InputData : Usecase의 Input, Command/Query
- 4. InputBoundary : UseCaseInteractor의 추상 Interface
- 5. OutputBoundary : Handler를 추상화하는 OutputBoundary 컴포넌트도 정의는 가능
  - 이게 현실적으로 가능한가?
  - controller 인터페이스를 app이 정의하게되면 input, output은? 전부 추상화하면 가능은 함
  - 책에는 이를 쌍방향 다형적 Boundary 인터페이스라고 정의

3. Driving Adapter

- Controller
- VM

## 추가적인 컴포넌트들

### 험블객체 패턴
- 특정 객체가 지나치게 복잡하거나 테스트하기 어렵다면, 테스트를 위해 기술적이고 구현하기 어려운 코드들을 하나의 객체로 몰아 두개로 분리시키는 전략
- 테스트하기 어려운걸 담는 객체는 보잘것없다Humble

## ORM은 DB계층 DataAccess 컴포넌트에 해당한다
## 게이트웨이, 클라이언트, 리스너

# 아키텍처 경계짓기

## 완벽한 경계의 클린아키텍처?
- 아키텍처 경계를 완벽하게 만드는데는 비용이 많이든다.
- 경계를 나누는데 너무 큰 비용이 들고, 애자일 커뮤니티에 속한 많은 이가 이런 선행적인 설계를 YAGNI 위배라고 좋아하지않음
  - You arent Going to Need it!


## 모듈화는 포기하고 패키지레벨의 부분적 경계만 나누는게 일반적 실무 타협선


## 양방향 바운더리 구현이 너무 과하다생각한다면 단순 DIP
- 컨벤션으로 아키텍처를 유지하지만 장기적으로 붕괴가능성 존재

## 이조차 과하다생각한다면 Facade
- 다만 클라이언트는 이경우 모든 서비스 클래스에 대해 추이종속성을 갖게됨
  - 서비스클래스 하나만 소스코드가 변경되어도 Client도 재컴파일
  - Facade캡슐화가 깨지면 Client가 서비스를 알게될수도있음
  - 장기적으로 아키텍처 붕괴 가능성
