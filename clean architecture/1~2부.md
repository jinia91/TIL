
# 1부

## Chapter 1. 설계와 아키텍처

### 1. 설계 design == 아키텍처 architecture
- 고수준 저수준 의미없음 모두 포괄해야하는것

### 2. 목표는?
- 소프트웨어 아키텍처의 목표는 필요한 시스템을 만들고 유지보수하는데 투입되는 리소스를 최소하는것
- ‘클린’ 하지 못한 소프트웨어의 변경은 스프린트 단위 이상의 리소스를 요구하게 될 확률이 높음
- 결국은 유지보수의 효율, 생산성을 위함
- 새로운 기능을 출시할때마다 비용이 증가한다면 나쁜설계

### 3. 소프트웨어가 커질수록, 더 커지기 위해서 투입되는 리소스가 커지는 상황
- 기술부채는 과연 갚을수 있는건가?
- 시장의 성장 속도, 변화속도에 대응하기위해 끊임없이 변화해야하는데 기술부채는 언제 갚지?
- 처음부터 `어느정도` `클린하게` 설계하고 코드를 작성하는 능력이 중요하지 않을까?
### 4. 저자의 주장은 클린한, 좋은 개발방식이 항상 옳다는것
- TDD
- 의존성관리
- 클린코드
- 클린한 아키텍처
- OOP


## Chapter 2. 두가지 가치에 대한 이야기

### 1. Software?
1. 소프트웨어의 본질은 부드러움, 하드웨어가 아니므로, 변경이 자유롭고 진화가능함의 존재
2. 그렇다면 기존 아키텍처가 변화와 기능추가를 받아들이기 힘들다면? 
3. 이를 막기 위해서는 아키텍처는 행태에 독립적이여야한다!

### 2. 행위 (behavior == feature&&change) vs 아키텍처 design


### 3. 아이젠하워 매트릭스
- 중요함, 긴급함	중요함, 긴급하지 않음
중요하지 않음, 긴급함	중요하지않음, 긴급하지 않음
=> 현실은 긴급한 문제가 아주 중요한문제일 경우는 드물고, 중요한 문제가 긴급한 경우도 드물다는 사실

중요한건 아키텍처다! (라고 저자는 말함)

### 소고 : 복잡함을 이해하고, 구조를 해석하는 능력은 얻기 어려움, 이런 능력을 가진 개발자들은 비싸다.
하지만 좋은 아키텍처 설계 위해 구현된 앱은 이해하기 쉽고 저숙련 개발자들이 참여하기 쉬워진다.
- 훌륭한 아키텍트 밑에 저숙련 개발자 몇명으로도 개발 리딩이 가능하게 할것인가?
- 고,중숙련 개발자들 다수를 뽑아 고비용으로 앱개발을 진행할것인가?


# 2부


## Chapter 3. 패러다임 개요

### 1. 구조적 프로그래밍
- 제어흐름의 직접적인 전환에 대해 규칙을 부과
- GoTo를 쓰지마라(do not it!)
### 2. 객체지향 프로그래밍
- 제어흐름의 간접적인 전화에 대한 규칙을 부과
- 함수포인터를 직접 사용하지마라(do not it!)
### 3. 함수형 프로그래밍
- 할당문에 규칙을 부과
- 지역변수 불변성, 변경 불가(do not it!)

### 프로그래밍은 너무 자유롭다
- 자유로움은 곧 룰이 없음을 의미, 앱이 규모가 커질수록, 협업 규모가 커질수록 강제되는 룰이, 아키텍처가, 컨벤션이 생산성을 높인다


## <1> 구조적 프로그래밍 패러다임
- 문제해결의 중요한 알고리즘은 바로 재귀적 분해 방식인 분할정복방식
- 모듈을 쪼개기 위해 생각할때, goto 문장은 지나치게 자유로움
- 이보다는 제한적인 제어구조가 유용하다

고수준의 문제 -> 중수준의 모듈 -> 저수준의 함수(코드)로 분할정복 가능!

### 테스트는 프로그램이 잘못되었음을 증명가능(반증가능)
=> 그렇다면 좋은 프로그램은 반증하기 쉬운 프로그램
=> testable한 프로그램

어떻게 해야 testable한 프로그램인가?

### 소고

1. goTo를 쓰면 안되는이유

        int findSum(int n) {
            int sum = 0;
            start:
                if (n <= 0) goto end;
                sum += n;
                n--;
                goto start;
            end:
                return sum;
        }

        int findSum(int n) {
            int sum = 0;
            for(int i = n ; i > 0 ; i--){
                sum += i;
            }
            return sum;
        }

GoTo는 너무 자유로워서 논리적인 이해와 분석에 어려움을 준다

위의 예시는 단순 funtion 내의 goto 지만, 클래스단위, 애플리케이션단위로 goto가 난무한다면? 


2. goto를 쓰지 않음으로서 문제를 해결하기위해 접근할때 분할정복하기 쉬워짐
3. 분할 정복을 통해 고수준의 문제를 중수준의 모듈로 쪼갤때, 모듈이 완벽하다, 옳다라는 증명은 불가능하다.
4. 왜냐면 비즈니스 법칙대로 동작한다고 시연은 가능해도, 비즈니스 법칙이 옳다고 시연은 불가능하기 때문
5. 또한 비즈니스 법칙은 항상 변경될수 있기때문에, 수학적으로 항상 옳은 모듈은 존재하지 않음
6. 다만 위의 비즈니스 법칙대로 동작한다고 시연은 가능
7. 이는 곧 비즈니스 법칙대로 동작하지 않는다고 반증은 가능
8. 반증은 테스트코드로한다
9. 테스트코드는 모듈이 틀렸음을 증명가능!
10. 테스트코드로 반증되지 않는 모듈은 ‘일단’ 신뢰가능한 모듈이다.
11. 따라서 좋은 모듈은 수많은 테스트코드로 반증되지않는 모듈
12. 또한 좋은 모듈이 되기위해서는 수많은 테스트코드를 작성하기 쉬워야한다.
13. testable한 모듈이 좋은 모듈이다!

그럼 testable한 모듈은 어떻게 만들지?



## <2> 객체지향 프로그래밍
- 실제세계를 모델링? => 저열한 대답

### 1. 객체지향의 세 요소 : 캡슐화, 상속, 다형성
    1. 이중 가장 핵심은 다형성
    2. 다형성을 포인터 신경 안써도 구현가능하게 해주는것!
    3. 핵심은 인터페이스

객체 지향의 가장 큰 핵심은 의존성을 인터페이스를 통해 역전시켜 변경을 플러그인을 바꿔끼우듯이, 어댑터를 바꿔끼우듯이 쉽게 해주는것

=> 핵심 프로그램이 장치에 독립적!

### 결국 OOP의 핵심은 의존성 관리
- 핵심 프로그램이 외부 변경에 의존하지 않는것
- 도메인과 포트 & 어댑터
- 모듈과 모듈끼리도 의존성을 제대로 관리하면 배포독립성 확보가능

### 소고 : 이러한 의존성 관리의 성공은 모듈단위 단위 테스트를 작성하기 쉽게 만들고
이는 곧 testable한 모듈이 됨을 의미

=> OOP적으로 의존성이 잘 관리된 모듈이 testable한 모듈이다

## <3> 함수형 프로그래밍

함수형 프로그래밍의 가장 큰 특징은 체이닝동안 변수의 불변성을 보장한다는것

절대적인 불변성은 불가능하므로 불변 컴포넌트에서는 순수하게 함수형 방식으로만 작업이 처리되고, 가변 컴포넌트에서만 가변변수들을 다루는것이 바람직


이것을 극단적으로 추구하는것이 바로 이벤트 소싱

=> 트랜잭션 자체를 저장함으로서 가변 변수 자체를 제거

CRUD가 아닌 CR로만 이루어진 애플리케이션이 가능해진다




