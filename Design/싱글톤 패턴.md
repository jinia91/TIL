---


---

<h2 id="싱글톤-패턴">싱글톤 패턴</h2>
<p>클래스의 인스턴스가 딱 하나만 생성되는것을 보장하는 디자인 생성 패턴</p>
<p>전역변수(global)를 사용하지 않으면서 생성된 객체를 어디서든지(public) 참조할 수 있도록한다.</p>
<h3 id="싱글톤-객체가-필요한-이유">싱글톤 객체가 필요한 이유?</h3>
<p>웹애플리케이션은 보통 여러 클라이언트의 요청을 동시에 처리해야한다.</p>
<p>배달의 민족 같은경우 TPS(transactions per second)가 최대 5만건으로 알려져있고, 국내에서 13번째로 유니콘기업으로 선정된 몰로코는 TPS가 최대 200만건에 달할정도로</p>
<p>웹서비스는 수많은 요청을 동시에 처리해야한다.</p>
<p>만약 클라이언트의 요청에 각각 반응하여 해당 서비스 로직과 컨트롤러, DAO등의 객체를 전부 만든다면?</p>
<p>아무리 고사양의 서버라도 메모리가 버티질 못할것이다.</p>
<p>이를 해결하기 위해 애플리케이션 전체에서 공유되는 단 하나의 객체(Singleton)가 모든 요청을 처리하도록 설계하는 패턴이 바로 싱글톤 패턴이다.</p>
<h3 id="싱글톤-패턴의-예시">싱글톤 패턴의 예시</h3>
<p>public class MemberDAO {</p>
<pre><code>// 싱글톤 설계
private static MemberDAO dao = new MemberDAO();

private MemberDAO() {
};

public static MemberDAO getInstance() {

	return dao;
}
// 싱글톤 설계
</code></pre>
<p>내가 MVC 모델기반 게시판 토이프로젝트에서 실제로 사용했던 코드다.</p>
<p>싱글톤 패턴의 구조는 우선 아래와 같이</p>
<ol>
<li>클래스가  정적(static) 선언한 참조변수에 자신의 인스턴스를  담는다.</li>
<li>이때 참조변수는 접근제한자(private)를 통해 외부 클래스에서 접근을 차단한다.</li>
</ol>
<blockquote>
<p>private static MemberDAO dao = new MemberDAO();</p>
</blockquote>
<ol start="3">
<li>클래스의 생성자메소드를 접근제한자(private)로 막는다. 이로인해 외부에서는 해당클래스의 인스턴스를 생성할수 없게 된다.</li>
</ol>
<blockquote>
<p>private MemberDAO() {};</p>
</blockquote>
<ol start="4">
<li>현재 정적선언을 통해 JVM 메모리의 static영역에 클래스의 인스턴스를 참조하는 참조 변수가 저장되어있다.</li>
<li>그러나 해당 변수는 접근제어자 private이므로 static 멤버이지만 global 멤버는 아니며, 외부 클래스는 해당 클래스의 static에 올라가있는 인스턴스에 접근할수 없다.</li>
<li>또한 유일한 생성자가 private으로 캡슐화되어있어 새로운 인스턴스를 만들수도 없다.</li>
<li>이때, 해당 클래스가 참조변수의 주소값을 반환할 수 있는 전역(global = public static) 메소드를 제공한다.</li>
</ol>
<blockquote>
<p>public static MemberDAO getInstance() {<br>
return dao;<br>
}</p>
</blockquote>
<ol start="8">
<li>이로서 단하나의 인스턴스만을 허용하고 보장하는 코드가 완성되었다.</li>
</ol>
<p><code>싱글톤을 구현하는 패턴은 이외에도 여러가지가 있다.</code></p>
<h3 id="싱글톤-패턴의-단점">싱글톤 패턴의 단점</h3>
<ul>
<li>싱글톤 패턴을 구현하는 코드 자체가 많이 들어간다.</li>
<li>의존관계상 클라이언트가 구체 클래스에 의존하며, DIP를 위반한다.(인터페이스에 의존하지 않는다는 뜻)</li>
<li>클라이언트가 구체 클래스에 의존해서 OCP 원칙을 위반할 가능성이 높다.</li>
<li>테스트하기 어렵다.</li>
<li>내부 속성을 변경하거나 초기화 하기 어렵다.</li>
<li>private 생성자로 자식 클래스를 만들기 어렵다.</li>
<li>결론적으로 유연성이 떨어지며, 실무에서 안티패턴으로 여겨진다.</li>
</ul>
<h3 id="스프링과-싱글톤">스프링과 싱글톤</h3>
<p>위를 통해 싱글톤의 장점과, 싱글톤 패턴의 단점에대해 알아봤다.</p>
<p>주의할 점은 <strong>싱글톤</strong>의 장점과 <strong>싱글톤 패턴</strong>의 단점이라는점이다.</p>
<p>싱글톤 패턴은 현재 실무에서 위의 수많은 단점으로인해 사용하기 어렵지만</p>
<p>스프링컨테이너는 <strong>싱글톤패턴을 적용하지 않고도</strong>, 객체 인스턴스를 싱글톤으로 관리할수 있게 해준다.</p>
<p>따라서 스프링 프레임워크를 사용한다면 <strong>싱글톤의 단점</strong>만을 유의하면 된다.</p>
<h3 id="싱글톤의-단점">싱글톤의 단점?</h3>
<p>싱글톤 패턴이든, 스프링 같은 싱글톤 컨테이너를 사용하든, 객체를 하나만 생성해서 공유하는<br>
싱글톤 방식은 여러 클라이언트가 하나의 같은 객체를 공유하기 때문에 상태를 유지(stateful)하게 설계하면 안된다.</p>
<p>즉 싱글톤객체를 설계할 때는 무상태(stateless)를 지향하여 설계해야만 한다.<br>
여기서 무상태란</p>
<ul>
<li>싱글톤 객체는 특정 클라이언트에 의존적인 필드가 있으면 안된다.</li>
<li>특정 클라이언트가 값을 변경할 수 있는  필드가 있어서는 안된다.</li>
<li>가급적 읽기만 가능해야 한다.</li>
</ul>
<p>만약 싱글톤 객체가 공유필드를 갖고있다면 멀티쓰레드 환경에서 치명적인 문제가 발생할 수 있다!</p>

