# SQL 패러다임
## Union을 사용

### Union을 사용한 조건분기의 문제점
 - Union은 기본적으로 여러 쿼리를 단순히 합쳐서 반환해주는 방식으로 동작
 - 사실상 여러 쿼리를 날리는것과 동일
 > 조건분기를 where구로 하느 사람은 초보자다. SQL을 잘 다루는 사람은 Select 구만으로 조건분기를 한다.

## Case 구문을 사용해서 조건 분기를 식으로 탑재하기

- Case 구문자체는 `분기처리`하는 로직을 담고 있음
- 분기처리된 결과 자체를 집합물(`2차원 테이블`)로 반환받음으로서 잦은 I/O 조회(`여러 쿼리를 for문으로 날리기`)에서 벗아날 수 있음
- SQL을 구문(`Sentence`)이 아닌 식(`Expression`)으로 사고한 결과

### 책에서의 소결
- 많은 쿼리 == 잦은 I/O는 많은 오버헤드를 낳고, 이러한 오버헤드는 성능 저하를 야기
- 되도록 I/O 접근 빈도를 줄이는 것이 성능 개선의 key
- 이를 위해서는 SQL 을 구문이 아닌 식(`expression`)으로 바라보는 관점이 중요
- SQL을 식(`expression`)으로 사고하면 SQL로 반환받는 데이터를 집합적인 관점으로 바라볼 수 있게 됨

# CHAPTER 5. 반복문

## SQL을 구문으로서 사고할때 -> 절차 지향적 접근

- 절차지향적인 접근은 반복문과 분기를 필연적으로 동반하고, 이는 잦은 DB조회를 낳음
- SQL은 기본적으로 반복문이 존재하지 않음
    - PL/SQL을 통해서 구현은 가능
    - 하지만 이는 SQL의 고전적 패러다임을 벗어난 접근법

> RDB를 처음 고안했던 Edgar F.Codd는 '관계 조작은 관계 전체를 모두 조작의 대상으로 삼는다. 이러한것의 목적은 반복을 제외하는 것이다. 최종 사용자의 생산성을 생각하면 이러한 조건을 만족해야 한다. 그래야만 응용프로그래머의 생산성에도 기여할 수이 있을 것이다.'


- RDB와 SQL은 태생에서부터 의도적으로 `반복문`을 배제한 언어이며, 이를 위해 집합적인 사고방식이 필요

> SQL은`집합에서 원하는 데이터를 조회하는` 것이지 절차적으로 데이터를 뽑아오는 개념이 아니다!

## 반복계 쿼리의 문제점

### 많은 오버헤드를 필연적으로 동반
1. SQL 구문을 네트워크로 전송
2. 데이터베이스 연결
3. SQL 구문 파싱
4. SQL 구문의 실행계획 생성 또는 평가
5. 결과집합을 네트워크로 전송

특히 3, 4번의 오버헤드는 필연적으로 발생하며 감소시키기도 매우 어려움

### DB차원에서 병렬 분산이 힘들다

단순쿼리는 리소스를 분산해 병렬적으로 처리하기가 애매함

### DB의 진화로 인한 혜택을 받기 힘듬
 
- 현대 데이터베이스의 성능향상 / 기술발전은 대규모 데이터를 다루는 복잡한 SQL구문을 빠르게 하는데에 치중되어있음
- 따라서 작은 쿼리일수록 성능 향상은 미비할수밖에 없음

## 반복계 쿼리를 빠르게 만들기 위해서는?

### 포장계로 쿼리 재작성...
### 각각의 SQL 을 최대한 최적화
- 하지만 반복계 쿼리는 기본적으로 매우 단순하기때문에 성능최적화에 한계가 존재
### 다중화처리
- DB를 샤딩하여야 하는데 RDB에 적합한 문제 해결방법으로 보기 어려움

## 반복계의 장점
### 실행계획의 안전성
- 단순한 쿼리는 기본적으로 옵티마이저가 해석하기 쉽기때문에 실행계획이 안정적이며, 실행계획이 갑자기 바뀌는 리스크가 매우 낮음

### 트랜잭션 제어가 편리
- 단순한 쿼리는 트랜잭션 자체도 짧기 때문에 정밀도를 미세하게 제어하기 쉽고, 전체 로직을 다루기도 쉬움


#
