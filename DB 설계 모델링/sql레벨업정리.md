# SQL 언어의 패러다임 이해

## Set-Oriented-Aspect

![첨부 이미지](https://jinia-img-bucket.s3.ap-northeast-2.amazonaws.com/ad02b31c-7faf-4717-b1c5-07c91be9303e.png)

* SQL은 구문 하나 하나가 Statement가 아닌 Expression
* 따라서 Expression의 조합을 통해 질의 안에 로직을 태울수 있음
* 또한 집합 지향 사고를 통해 질의의 반환을 2차원 테이블 구조로 반환 가능
* 집합지향 사고를 통해 반복적인 조회(for-each)를 없앨 수 있음

## SQL을 Statement로 사고하기 -> 절차 지향적 접근

* 절차지향적인 접근은 반복문과 분기를 필연적으로 동반하고, 이는 잦은 DB조회를 낳음
* SQL은 기본적으로 반복문이 존재하지 않음
    * PL/SQL을 통해서 구현은 가능
    * 하지만 이는 SQL의 고전적 패러다임을 벗어난 접근법

> RDB를 처음 고안했던 Edgar F.Codd는 '관계 조작은 관계 전체를 모두 조작의 대상으로 삼는다. 이러한것의 목적은 반복을 제외하는 것이다. 최종 사용자의 생산성을 생각하면 이러한 조건을 만족해야 한다. 그래야만 응용프로그래머의 생산성에도 기여할 수이 있을 것이다.'

* RDB와 SQL은 태생에서부터 의도적으로 `반복문`을 배제한 언어이며, 대신에 집합적인 사고방식을 통해 해결

> SQL은`집합에서 원하는 데이터를 조회하는` 것이지 절차적으로 데이터를 뽑아오는 개념이 아니다!

## for-each 쿼리의 문제점

### 많은 오버헤드를 필연적으로 동반

* 애플리케이션이 DB에 접근할때 발생하는 오버헤드들
    1. SQL 구문을 네트워크로 전송
    2. 데이터베이스 연결
    3. SQL 구문 파싱
    4. SQL 구문의 실행계획 생성 또는 평가
    5. 결과집합을 네트워크로 전송

특히 3, 4번의 오버헤드는 필연적으로 발생하며 감소시키기도 매우 어려움

### DB차원에서 병렬 분산 처리가 힘들다

단순쿼리는 연산 자체가 워낙 가벼워서 리소스를 분산해 병렬적으로 처리하기도 애매함

### DB의 진화로 인한 혜택을 받기 힘듬

* 현대 데이터베이스의 성능향상 / 기술발전은 대규모 데이터를 다루는 복잡한 SQL구문을 빠르게 하는데에 치중되어있음
* 따라서 작은 쿼리일수록 성능 향상은 미비할수밖에 없음

## 만약 for-each 쿼리 속도를 개선하려면?

### 빅-쿼리 재작성...

### 각각의 SQL 을 최대한 최적화

* 하지만 반복계 쿼리는 기본적으로 매우 단순하기때문에 성능최적화에 한계가 존재

### DB 다중화처리

* DB를 샤딩하여야 하는데 RDB에 적합한 문제 해결방법으로 보기 어려움

## for-each 장점

### 실행계획의 안전성

* 단순한 쿼리는 기본적으로 옵티마이저가 해석하기 쉽기때문에 실행계획이 안정적이며, 실행계획이 갑자기 바뀌는 리스크가 매우 낮음

### 트랜잭션 제어가 편리

* 단순한 쿼리는 트랜잭션 자체도 짧기 때문에 정밀도를 미세하게 제어하기 쉽고, 전체 로직을 다루기도 쉬움

##  For-each 질의의 예시

> Union을 통해 살펴보기

### Union을 사용한 조건분기의 문제점

* Union은 기본적으로 여러 쿼리를 단순히 합쳐서 반환해주는 방식으로 동작
* 사실상 여러 쿼리를 날리는것과 동일

> 조건분기를 where구로 하느 사람은 초보자다. SQL을 잘 다루는 사람은 Select 구만으로 조건분기를 한다.

## Case 구문을 사용해서 조건 분기를 식으로 탑재하기

* Case 구문자체는 `분기처리`하는 로직을 담고 있음
* 분기처리된 결과 자체를 집합물(`2차원 테이블`)로 반환받음으로서 잦은 I/O 조회(`여러 쿼리를 for문으로 날리기`)에서 벗아날 수 있음
* SQL을 구문(`Sentence`)이 아닌 식(`Expression`)으로 사고한 결과

## 소결

* 많은 쿼리 == 잦은 I/O는 많은 오버헤드를 낳고, 이러한 오버헤드는 성능 저하를 야기
* 되도록 I/O 접근 빈도를 줄이는 것이 성능 개선의 key
* 이를 위해서는 SQL 을 구문이 아닌 식(`expression`)으로 바라보는 관점이 중요
* SQL을 식(`expression`)으로 사고하면 SQL로 반환받는 데이터를 집합적인 관점으로 바라볼 수 있게 됨

## 하지만 현대 애플리케이션에서 DB중심 설계는?

* 현대 어플리케이션은 데이터 중심 설계에서 벗어나 비즈니스 로직을 최대한 서버단에서 처리하고, DB는 저수준의 CRUD 정도로만 사용하려는 트렌드
* Set-Oriented-Aspect 는 성능을 위해 반복문, 조건분기를 DB단으로 자연스럽게 끌고오게되며, 데이터 중심의설계를 유도할수밖에 없다.

### 웹서버와 DB서버의 scaleability 차이

* 웹서버는 scale up, out 모두 용이한편
* 하지만 RDB의 경우 기본적으로 scale up만 가능하고, scale out은 복잡도와 비용이 매우 높고, scale up 자체의한계도 존재

### 유지보수 관점

* 집합적인 사고 자체가 직관적이라고 말하기 어려우며, 가독성이 좋다고 말하기도 힘듬
* 데이터 중심의 애플리케이션 설계는 애플리케이션의 아키텍처가 영속성계층에 지나치게 종속되는 결과를 만들고, 유지보수를 어렵게 만듬

### 성능 - 설계 트레이드오프

* 로직을 애플리케이션단으로 끌고오면, 아무래도 최적의 쿼리를 작성하기엔 어려워지고, 필연적으로 db단 조회는 증가, 더 많은 오버헤드를 만들수밖에 없음
* 하지만 짧은 트랜잭션을 통한 안전성, 유지보수의 편의를 생각하면 현대 애플리케이션의 설계는 비즈니스 로직을 서버단에서 하는것이 더 낫다 판단됨

### 소결

* 집합적 사고와 선언형 언어의 이해를 바탕으로 저수준의 sql 최적화는 여전히 필요하다고 생각
* 트레이드 오프를 잘 고려하자
