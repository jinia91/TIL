# 프로세스 프로그램
- 실행가능한 파일 : 프로그램
- 실행중인 프로그램 : 프로세스
- 커널도 프로그램


# 커널
- 응용 프로그램(애플리케이션)이 직접 장치에 접근하여 조작하는것은 매우 위험함
  - 저장장치에 두 프로세스가 동시에 접근해 동시에 읽고 쓰는 작업을 수행한다고 생각해보자. 최악의 경우 뻑이나 벽돌이 되버릴수도...
- 커널은 하드웨어의 도움을 받아 이런 접근 권한을 제어함
- 리눅스 커널은 기본적으로 2개의 모드이며 아키텍처에 따라 추가적인 모드들이 더 있음
  - 커널모드 : 제약이 없음, 커널만이 커널모드로 동작해 장치에 접근 가능
  - 사용자모드 : 제약이 존재. 사용자 공간에서 프로세스를 실행
 
# 시스템 콜
- 프로세스가 커널에 처리를 요청하느 방법
- 새로운 프로세스 생성, 하드웨어 조작처럼 커널의 도움이 필요할떄 사용

  ## 예시
  - 프로세스 생성, 삭제
  - 메모리 확보, 해제
  - 통신 처리
  - 파일 시스템 조작
  - 장치 조작
 
- 프로세스가 시스템콜을 호출하면 예외가 발생
- 커널이 요청이 올바른지 검증, 올바르지 않다면 시스템콜 실패
- cpu모드가 사용자 모드에서 커널모드로 바뀌고, 요청 내용에 따라 커널처리가 동작
- 커널 내부에서 시스템콜 처리가 끝나면 사용자모드로 돌아와서 프로세스 동작이 이어진다.


# strace 로 시스템콜 확인해 보기
<img width="1004" alt="image" src="https://github.com/user-attachments/assets/bb3eabb0-f811-4f18-829d-26b20a15cace">

고든 파이썬이든 단순히 hello world를 찍기위해서 150라인이 넘는 strace가 찍힌다


# 시스템 콜을 처리하는 시간 비율

<img width="669" alt="image" src="https://github.com/user-attachments/assets/3805bf04-fad1-4a2a-9005-f7fc858d68da">

- taskset으로 0번 시피유에 무한루프 태스크를 할당하고 sar로 관측
- 단순 무한루프이므로 usr 100%

  <img width="689" alt="image" src="https://github.com/user-attachments/assets/07904da5-2587-46f5-868c-402823218b07">
- getppid 로 프로세스 id를 얻는 시스템콜을 섞을경우 시스템 콜에 해당하는 system의 비율이 많아짐을 확인 가능
- 커널모드와 사용자모드를 넘나들고 있음을 확인해볼 수 있다

# 시스템콜 래퍼함수
- 시스템콜은 기본적으로 어셈블리언어로 호출하며 c로도 직접호출은 불가능
- 단 c로 래핑된 함수가 존재하며, libc는 표준 시스템 콜 래퍼 함수도 제공한다(일반적으로 gnu libc는 커널이 다 내장함)
- 운영체제 외부 라이브러리 영역으로서 존재

# 정적 라이브러리와 공유 라이브러리
- 소스코드를 컴파일하면 오브젝트 파일이 생성됨
- 오프젝트 파일이 사용하는 라이브러리를 링크해서 실행파일을 만듬
- 정적 라이브러리는 링크할 떄 라이브러리에 있는 함수를 프로그램에 집어넣는다
- 반면 공유라이브러리는 링크할 때 이 라이브러리의 이런 함수를 호출한다는 정보만 실행파일에 포함한다
- 프로그램 시작하거나 실행중에 라이브러리를 메모리에 로드하고 프로그램은 그 안에 있는 함수를 호출
- cc로 컴파일시 정적 컴파일 옵션을 넣으면 사용 라이브러리들을 모두 모아 컴파일이 가능
- java로 치면 fatJar하는 느낌
- 사이즈가 매우 차이나고 공유라이브러리의 업데이트가 수월하다는 장점이 존재
- ldd 명령어로 어떤 공유 라이브러리가 링크되어있는지 확인가능하다

 <img width="653" alt="image" src="https://github.com/user-attachments/assets/5c629ef5-429f-46d5-84c0-4e8a976da564">


# go는 정적라이브러리를 사용
- 대용량 메모리나 저장장치가 널리 사용되어 파일 크기문제가 과거에 비해 덜중요
- 실행 파일 하나로 프로그램이 동작한다면 이식성이 더 뛰어나짐
- 실행할 때 링크할필요가 없으므로 시작시간이 더 빠름
- 공유라이브러리의 DLL 지옥(호환성 꺠짐)으로부터 자유로움
