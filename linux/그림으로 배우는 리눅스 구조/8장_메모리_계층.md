# 개요
- 기억장치 계층구조를 고려하여 리눅스가 어떻게 데이터를 핸들링하는지 정리

# 레지스터
- 프로세스 레지스터 또는 레지스터
- CPU가 현재 계산을 수행중인 값을 저장하는데 사용
- 대부분의 현대 프로세서는 메인 메모리에서 레지스터로 데이터를 옮겨와 데이터를 처리한 후 그 내용을 다시 레지스터에서 메인 메모리로 저장하는 로드 - 스토어 설계를 사용

![image](https://github.com/user-attachments/assets/cc402590-004d-4868-9c6f-6a1b257fde5d)


## 구성
- pc(프로그램 계수기) : 다음에 실행할 명령어의 주소를 가지고 있음
- IR(명령어 레지스터) : 현재 수행중인 명령어를 가지고 있음
- MAR(메모리 주소 레지스터) : 메모리로부터 읽어오거나 메모리에 쓰기 위한 주소를 가지고 있음
- MBR(메모리 버퍼 레지스터) : 메모리고부터 읽엉온 데이터 또는 메모리에 써야할 데이터를 가지고 있음
- I/O AR (입출력 주소 레지스터) : 입출력 장치에 따른 입출력 모듈의 주소를 가지고 있음
- I/O BR (입출력 버퍼 레지스터) : 입출력 모듈과 프로세서 간의 데이터 교환을 위해 사용


## CPU 동작 개략
1. 명령을 읽고 명령 내용에 따라 메모리에서 레지스터로 데이터 읽기
2. 레지스터에 있는 데이터를 가지고 계산
3. 계산 결과를 메모리에 다시 저장


CPU의 계산시간이 메모리 접근시간보다 훨등히 빠르기때문에 1과 3에서 메모리 Read / Write시 병목이 발생하고 이를 해결하기 위해 캐시 메모리를 사용한다


# 캐시 메모리
- 메모리에서 레지스터로 읽어들일때 캐시 메모리에 캐시라인이라고 부르는 단위로 데이터를 읽어서 그 데이터를 레지스터로 옮긴다(레지스터가 한번에 읽는 단위 == 캐시 라인)

![image](https://github.com/user-attachments/assets/756c3270-9660-476c-8c49-a62391ae3ff7)

- 캐시에 한번 읽어들인 라인은 레지스터로 재 로드시 메모리에 있는 데이터보다 훨씬 빠르게 로드 가능
- 특히 read & Write 수정작업이라고 생각하면 한번 캐시 메모리로 올려놓은 뒤 캐시라인으로 원본을 레지스터에 읽고 이를 수정한 라인을 다시 레지스터에 두고 이를 다시 캐시 메모리에 write하므로서 병목을 어느정도 해소할 수 있음
- 이때 캐시 메모리의 수정된 캐시라인은 dirty를 표시
- 만약 캐시 메모리가 가득찼다면 기존 캐시라인중 하나를 버리고 새로운 캐시를 불러오는데 이때 더티 캐시라인이라면 메모리로 기록하는 clean 처리를 수행
- 만약 잦은 메모리 접근이 발생하면 잦은 스레딩 현상이 발생한다


## 참조 지역성

- write&back 방식이라면 지연 flush를 하기때문에 캐시 메모리로 한번에 캐시라인을 잘 만들면 잦은 메모리 접근을 하지 않고도 인스트럭션을 수행 할 수 있다
- 메모리의 참조 지역성 특성을 잘 이래하면 많은 동작들을 이러한 방식으로 처리하여 더 나은 퍼포먼스를 낼 수 있게됨
- 시간 지역성 : 어떤 시점에 접근하는 메모리는 가까운 미래에 또다시 접근할 가능성이 높음(반복문)
- 공간적 지역성 : 어떤 시점에 메모리에 접근하면 가까운 미래에 그 근처에 있는 데이터에 접근할 가능성이 높음(배열)

# SMT
- CPU의 연산속도는 일반적인 장치 접근보다 압도적으로 빠르기때문에 아무리 캐시메모리를 사용하더라도 유휴 시간이 많이 발생함
- 이러한 물리적 유휴시간자체를 줄이기 위해 동일 하드웨어 CPU 하나가 여러 논리 CPU를 가지는 방향으로 발전중
- 특히 부동소숫점 연산과 정수연산은 다른 논리연산이므로 두가지 연산을 동시에 수행하며 SMT가 가능하면 하나의 물리CPU가 동시에 두가지연산을 할 수 있음

# 페이지 캐시
- 메모리 - 캐시 메모리 - 레지스터 관계처럼 저장장치 - 메모리 - 캐시 메모리에서의 메모리도 동일한 역할을 수행한다.
- 캐시메모리가 캐시 라인 단위로 데이터를 다루는것처럼, 메모리도 저장장치에서 페이지 단위로 데이터를 메모리에 로드하고 수정된 페이지는 더티 페이지로 표시하며 라이트 백 개념도 포함한다

## 프로세스가 저장장치의 데이터를 접근할때
1. 커널이 저장장치에 접근하여 필요한 데이터를 페이지 단위로 커널 메모밀 페이지 캐시 영역에 복사
2. 복사된 페이지를 다시 해당 프로세스의 메모리에 복사
3. java io 도 동일한 방식
4. nio라면 jvm이 직접 커널 메모리에 접근할 수 있다

https://homoefficio.github.io/2020/04/09/Java-Native-Memory-Tracking/

## 프로세스가 저장장치의 데이터를 수정할때
1. 접근과 동일한 절차
2. 수정시 커널은 페이지 캐시에만 데이터를 기록하고 더티 페이지로 마킹
3. 일정 타이밍에 라이트백 처리
4. 만약 더티 페이지상태에서 전원이 갑자기 꺼지면 제대로 저장되지 못한다(commit 되지 못한셈)


# 버퍼 캐시
- 디스크 데이터중에서 파일 데이터 이외의 것을 캐시하는 방식
- 파일 시스템을 사용하지않고 디바이스 파일로 저장장치에 직접 접근하거나 파일 크기나 권한등의 메타데이터에 접근할 때 사용

# 쓰기 타이밍
- 더티 페이지는 보통 백그라운드로 동작하는 커널의 라이트 백 처리에 따라 디스크에 저장
  - 주기적으로(약 5초) 동작
  - 더티 페이지가 늘어났을때 동작

- dirty_writeback_centisecs : 라이트 백 주기
![image](https://github.com/user-attachments/assets/8afcb09b-662c-4dfb-a824-23978862aca1)

- dirty_background_ratio : 시스템에 설치된 전체 물리 메모리중에서 더티 페이지가 차지하는 비율 한계선 : 해당 비율을 초과하면 백그라운드 스레드가 깨어나 라이트 백을 수행
![image](https://github.com/user-attachments/assets/6f21682b-ca19-4a33-85fa-6870c2311524)

- dirty_ratio : 더티페이지 비율이 빠르게 늘어서 해당 비율을 초과했다면 더티체킹없이 바로 sync로 flush하는 방식으로 동작 변경

![image](https://github.com/user-attachments/assets/16afdce6-69da-415c-955e-fdd8ddc230d6)


# 직접 입출력
- 페이지캐시나 버퍼캐시를 사용할 필요가 없는 유즈케이스가 존재함
  - 한번 읽고 쓰면 두번다시 사용하지 않는 데이터인경우: 백업
  - 프로세스가 자체적으로 페이지 캐시에 해당하는 기능을 구현한 경우

- direct I/O를 사용하면 페이지 캐시없이 처리 가능

# 스왑
- 페이지 인(스왑 인) / 페이지 아웃(스왑 아웃) 을 통해 물리메모리 부족시 안쓰는 일부 메모리 영역을 저장장치에 저장하거나 저장장치에 저장된 해당 영역을 다시 가져오는 행위
- 스왑인을 위한 페이지 폴트가 메이저 페이지 폴트다(흔히 발생하는 폴트라 메이저라고 말한거같음. 마이너가 덜 중요한게아니라 오히려 마이너일때가 더 비정상인 상황인듯?)

# 통계정보
- sar -S 1 : 스왑 영역 이용 상황

kbswpused가 비정상수치라면 위험신호
