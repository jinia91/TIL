# 개요
- 리눅스는 커널의 '메모리 관리 시스템' 기능을 이용해 하드웨어의 메모리를 관리한다.
- 메모리는 각 프로세스가 사용할 뿐만 아니라 커널 자체도 사용

# 메모리 관련 정보 수집하기
free
|필드명|의미|
|--|--|
|total|전체|
|used|시스템이 사용중인 메모리에서 buff/cache를 뺀값|
|free|명목상 비어있는 메모리|
|buff/cache|버퍼, 캐시, 페이지 캐시가 이용하는 메모리, 시스템의 비어있는 메모리가 줄어들면 커널이 해제시킴|
|available|실제 사용가능한 메모리, free 필드값과 비어있는 메모리가 줄어들었을때 해제 가능한 커널 내부 메모리 영역 크기를 더한 값|

buff/cache는 커널이 사용중이며 해제가 불가능한 영역도 존재한다.

## used
- 프로세스가 사용중인 메모리와 커널이 사용하는 메모리 모두를 포함
- 캐시는 미포함

## buff/cache
- 페이지 캐시와 버퍼 캐시가 사용하는 메모리 용량

<img width="673" alt="image" src="https://github.com/user-attachments/assets/6f16cb6a-abd5-49e3-a47b-1d125a142d35">

- 파일을 만들면서 페이지 캐싱을 통해 데이터와 메타데이터를 저장했기 때문에 캐시에 존재하며 삭제시 캐시도 해제됨을 확인 가능

## sar 로 메모리 관련 정보 수집

<img width="1068" alt="image" src="https://github.com/user-attachments/assets/ee2ddcba-749f-4c0f-9a72-7cfda36ba5a2">

|free|sar -r|
|-|-|
|total|-|
|free|kbmemfree|
|buff/cache|kbuffers + kbcached|
|available|-|

## 메모리 재활용 처리
- free 메모리 부족시, buff/cache가 1순위로 해제되며 메모리가 확보된다
- 재활용 가능한 메모리를 해제해도 메모리 부족이 해결되지 않으면 시스템은 oom상태가 되며 메모리 관리 시스템이 적당히 프로세스를 골라서 강제 종료시킨다
-   - oom killer
 
  # 가상 메모리

## 가상 메모리가 없을때 생기는 문제점
### 메모리 단편화
- 프로세스를 생성하고 메모리를 확보와 해제를 반복하다보면 메모리 단편화 문제가 발생한다
- 파편화되는 메모리는 사용하기 굉장히 번거로움
### 멀티 프로세스 구현이 까다로워짐
- 프로그램은 aslr off시 어떤 메모리주소를 사용해 프로세스를 로드할지, 어떤 데이터 주소를 찾아갈지 어느정도 정적으로 정의된다
- 따라서 가상메모리가 없다면 물리메모리의 같은 위치에 2번째 프로세스가 실행하려 시도하는 문제가 발생한다
- 이를 고려한 메모리할당을 한다면 해결되나 개발난이도가 높아진다

### 비정상적인 메모리 접근
- 어떤 프로세스가 커널이나 다른 프로세스에 할당된 메모리 주소를 지정하면 자신이 사용하는 영역이 아님에도 접근할수 있는 문제가 발생
- 

## 가상 메모리 기능
- 프로세스가 메모리에 접근할 때, 물리메모리가 아니라 가상 주소를 사용해 간접적으로 접근하는 방법
- 가상 주소 공간을 활용한다
- 프로세스에서 실제 메모리에 직접 접근하는 방법, 물리주소를 직접 지정하는 방법은 없음

### 페이지 테이블
- 가상 주소를 물리주소로 변환하려면 커널 메모리 내부에 저장된 페이지 테이블을 사용
- cpu는 모든 메모리를 페이지 단위로 쪼개서 관리
- 주소는 페이지 단위로 변환
- 페이지 테이블에서 한페이지에 대응하는 데이터를 페이지 테이블 엔트리라고 부른다
- 페이지 크기는 cpu아키텍처에 따라 다름.
- 보통 4kb, m1 은 16kb인듯?

- 프로세스 실행시 커널이 프로세스용 페이지 테이블도 작성
- 가상 주소상 물리 메모리가 연결되지 않는 주소를 프로세스가 접근할경우 페이지 폴트가 발생한다
- 페이지 폴트는 SIGSEGV를 일으키고 이는 보통 강제종료 처리됨


## 가상 메모리로 문제 해결하기
### 메모리 단편화
- 단편화된 물리메모리들도 가상 주소를 이용하면 연속된 데이터 저장이 가능해지므로 문제되지 않음

### 멀티프로세스 구현의 어려움
- 가상 주소 공간은 프로세스마다 만들어지므로 동일한 프로그램이 여러개 실행되어도 문제되지 않음

### 비정상적인 메모리 접근
- 다른 프로세스의 물리메모리 주소를 알방법이 없으므로 접근 불가능해짐

# 프로세스에 새로운 메모리 할당하기
일반적인 커널의 프로세스 메모리 할당 절차
1. 프로세스는 xx 바이트 메모리가 피룡하다고 시스템 콜 호출로 커널에 요청
2. 커널은 시스템의 비어있는 메모리에서 xx 바이트 영역을 확보
3. 확보한 메모리 영역을 프로세스의 가상주소 공간에 매핑
4. 가상 주소공간의 시작위치 주소를 프로세스에 돌려줌

=> 이떄 메모리 영역은 할당하지만 물리메모리 할당 그 자체는 조금 시간이 지난후에 발생한다, lazy paging, demand paging 


## map과 mmap

<img width="785" alt="image" src="https://github.com/user-attachments/assets/72a87725-e415-459a-8a35-7cc6120fe74a">


 프로세스를 실행하고 해당 프로세스의 map을 까보면 위와같이 나온다.
 - 첫라인은 코드영역으로 프로세스 실행 코드가 올라간다
 - 두번쨰라인은 읽기전용영역으로 상수가 올라간다
 - 세번째라인은 읽기 쓰기 영역으로 전역변수 정적변수가 올락나다
 - 네번째 라인은 힙영역으로 추정
 - 그외에 stack이나 vvar 등의 영역이 할당된다

만약 여기서 mmap으로 별도의 메모리를 추가로 할당하려할경우

<img width="734" alt="image" src="https://github.com/user-attachments/assets/c77a9f0c-ee78-44a9-9e89-abfc20e16606">

6번째 라인에서 ffff8e87d000 이 fffff4e87d000으로 시작 위치가 바뀌며 확장되었다(8->4면 시작위치가 당겨졌으므로)

- 18년 이전까지는 리눅스는 커널 메모리를 가상 주소공간에 매핑했지만 멜트다운 이슈로 커널메모리는 더이상 가상 메모리에 매핑하지 않고 물리메모리에서 사용된다


## 메모리 할당: Demand paging

- mmap으로 가상메모리 할당을 추가할때 바로 물리메모리에 매핑되는것이 아니라 해당 가상 메모리 주소에 최초 접근시 물리메모리에 매핑을 한다.

- - 이는 비정상 가상 주소에 접근하는것과 유사하게 동작한다.
  - 매핑되지 않은 비정상 가상주소 접근시 페이지 폴트가발생
  - 하지만 페이지 테이블 엔트리가 존재하고 가상메모리만 할당되지 않은 경우라면 페이지 폴트 핸들러가 이를 새로운 메모리 할당으로 대응한다
 
<img width="1500" alt="image" src="https://github.com/user-attachments/assets/581cda80-7517-47eb-8b2c-c5f2a587d1e7">

- 실제 테이스를 해보면 18:11:44까지 메모리를 확보하지않아 커밋 %가 22.20에서 45초에 22.75로 메모리 커밋자체는 증가했지만, kbmemused 사용량 자체는 그대로임을 알 수 있다.
- 실제 메모리 접근이 시작되는 47초부터 보면 kbmemused memused가 10초간 꾸준히 증가한다
- 프로세스가 종료되는 58초 시점에 usde메모리와 커밋이 모두 회수됨을 확인가능하다

<img width="832" alt="image" src="https://github.com/user-attachments/assets/f9bae374-663a-4f09-b5b6-a5e15b31fa4f">

- '- B' 옵션으로 페이지 폴트를 보면 프로세스가 메모리를 할당하는 시점이 30초부터임을 대략적으로 짐작할 수 있다.

# 페이지 테이블 계층화
- 가상테이블을 만들때 단순히 2차원 테이블로 매핑하려하면 모든 가상주소할당수만큼 엔트리(행)을 비어있더라도 만들어줘야하기때문에 메모리사용량이 매우 커진다.
- 만약 계층화를 사용하면 훨씬 효율적인 메모리 공간 사용을 할  수 있다.
- 4/16 가상 메모리 매핑이 필요할경우 실제 4개의 물리주소만 매핑하려해도 16개의 엔트리가 필요하다.
- 만약 4열 max로 2계층화를 할경우 똑같이 16개의 물리메모리 매핑이 가능하면서 첫열 참조 테이블의 4개 + 최초 열의 4개 엔트리만해서 총 8개의 엔트리만으로 물리메모리 매핑이 가능해진다
- 물론 루트테이블의 4열이 가득차게 매핑한다면 20 엔트리로 평탄화 메모리보다 사용량이 더 크지만 이런경우는 보통 드물기떄문에 계층형을 사용하는게 더  유리하다
 
## huge page
- 페이지 자체를 크게 잡아 엔트리를 많이 만들지 않는 방법으로 데이터 자체가 일정하게 특정 사이즈여서 페이지를 작게 쪼갤필요가 없는 상황에서 세팅해볼만한 설정
- mmap() 인수에 MAP_HUGETLB 플래그로 설정가능
- fork()의 테이블 복사 비용도 줄어 더  빨라진다고함

## Transparent Huge Page
- 가상 주소 공간 내부에 연속된 여러 페이지가 특정 조건을 만족할 경우 그걸 묶어 자동으로 huge page로 바꿔주는 기능
- 해당 기능을 킬지 말지 커널 설정으로 세팅 가능하다





