# 프로세스 생성
새로운 프로세스를 생성하는 목적
- 동일한 프로그램 처리를 여러 프로세스에 나눠서 처리하기위함
  - fork()   
- 다른 프로그램을 생성하기
  - fork(), execve()
 
## fork() 동작
- 부모프로세스가 fork() 호출
- 부모 프로세스만큼의 메모리를 자식프로세스를 위해 확보하고 그곳에 부모 프로세스의 메모리를 복사
- 부모와 자식은 둘다 fork() 함수에서 복귀(동알한 pc 레지스트리까지 복사되므로 해당 pc 라인에서 복귀한다)
- 복사시 copy-on-write기능으로 물리메모리 복사는 일어나지않고 가상메모리만 복사하므로 오버헤드가 매우 적다
### 부모와 자식의 관계 더 알아보기 - 종료와 좀비, 고아
- 고수준 언어의 exit() 함수는 내부적으로 exit_group() 시스템콜을 호출
- 부모프로세스는 일반적으로 wait(), waitpid() 를 통해 종료된 자식 프로세스의 리턴 exit 값을 받아볼 수있음
- 부모 프로세스와 달리 자식 프로세스는 종료시점에 메인함수의 리턴값을 부모에게 전달해주는데 이때 부모가 리턴값을 회수하지 않은채 계속 실행되면 좀비 프로세스로 남는다
  - 부모가 종료되면 자식 프로세스도 종료되는데 init 프로세스에 의한건가?
- 반대로 부모가 먼저 종료되는경우 자식 프로세스는 고아프로세스가되나, 리턴값을 전달해주지 않더라도 init 프로세스가 주기적으로 점검하여 종료

- pstree를 통해 트리구조로 부모자식관계를 볼 수 있다
![image](https://github.com/user-attachments/assets/6ccd691f-cc9f-4b7d-99af-c1f121cf42bf)


## execve() 함수
- 프로세스를 바꾸는 함수
### 과정
- execve 함수 호출
- 함수 인수로 지정한 실행파일에서 프로그램을 읽어서 메모리에 배치하는데 필요한 정보를 가져옴
- 현재 프로세스의 메모리를 새로운 프로세스 데이터로 덮어 씌우기
- 프로세스를 새로운 프로세스의 최초에 실행할 명령부터 실행하기

### execve() 동작시 필요한것들
- 코드 영역의 파일 오프셋, 크기 및 메모리 맵 시작 주소
- 데이터 영역의 파일 오프셋, 크기 및 메모리 맵 시작 주소
- 최초로 실행할 명령의 메모리 주소(엔트리 포인트)

=> ELF 포멧을 사용해서 다룸

![image](https://github.com/user-attachments/assets/1fc8ca6f-3fc9-45a2-b3f1-fc78500bf602)

- 컴파일되는시점에 elf를 통해 가상메모리 어디에 배치할지를 지시, /proc/pid/maps로 실행중인 프로세스의 메모리 맵을 까볼수 있음
  - aslr을 꺼서 no pie상태에서 관측해야함
  - 컴파일시 동일한 위치라면 어떻게되지?


# ASLR
- ASLR은 프로세스가 실행될 때마다 프로세스의 주요 구성 요소인 코드, 데이터, 힙, 스택, 라이브러리 등의 위치를 무작위로 배치
- 보안관점
- `-no-pie` 옵션으로 수행
- 현대의 프로세스는 대부분 aslr로 메모리맵에대한 위치정보를 신경쓸필요가없다

# 프로세스 상태
![image](https://github.com/user-attachments/assets/70786aad-6602-4cde-9e66-6423e9d2c5fa)

- stat : 상태
- start : 시작 시간
- time : cpu 사용시간


![image](https://github.com/user-attachments/assets/51f2fb30-5052-4b7e-b958-320abe3466d9)

- 부모를 슬립걸어 자식을 좀비상태로 만들었을때 좀비 상태 캡쳐


1. **`R` (Running or Runnable)**:
   - `R`은 프로세스가 현재 실행 중이거나 실행을 위해 준비가 되어 있음. 이 상태의 프로세스는 CPU 시간을 얻기 위해 스케줄링 큐에 있거나, 현재 CPU에서 실행 중

2. **`S` (Interruptible Sleep)**:
   - 프로세스가 대기 상태에 있으며, 특정 이벤트나 조건을 기다리고 있음. 이 상태의 프로세스는 쉽게 깨어날 수 있으며, 신호 등에 의해 깨어날 준비가 되어 있음

3. **`D` (Uninterruptible Sleep)**:
   - 입출력 작업과 같은 기다릴 수 없는 작업을 수행 중인 프로세스의 상태. 이 상태는 신호에 의해 깨어날 수 없기 때문에 "디스크 슬립"이라고도함

4. **`T` (Stopped)**:
   - 프로세스가 일시 중지된 상태이며, 재개될 때까지 아무 작업도 수행하지 않음. 디버깅 또는 시스템 명령에 의해 중지될 수 있음.

5. **`Z` (Zombie)**:
   - 프로세스가 종료되었지만, 부모 프로세스가 아직 자식 프로세스의 종료 상태를 회수하지 않은 상태
   - 
### 추가 플래그

- **`+`**:
  - 이 플래그는 프로세스가 포어그라운드 프로세스 그룹의 일부임을 나타냄
- **s**:
  - 세션 리더임을 나타냄. 세션을 만들어내는 쉘에 보통 나타난다
 

# 시그널
- 특정 프로세스가 다른 프로세스에 어떤 신호를 보내서 외부에서 실행 순서를 강제로 바꾸는(강제로 특정동작을 실행시키는) 방법
- https://en.wikipedia.org/wiki/Signal_(IPC)
- 모든 프로세스는 각 시그널에 대해 시그널 핸들러가 미리 등록되어 있어 이를 핸들링함
- 반대로 이를 이용해 signal을 무시할수도있다
- 

![image](https://github.com/user-attachments/assets/8c8bd75e-6c4e-4bd2-9b28-00a17edbcf9d)

- siginit을 무시해서 컨트롤C와 kill이 안먹힌다!
- kill -9로 죽일수 있음


 # 쉘 작업 관리 구현

 ## 세션
 - 로그인 세션과 같이 단말로 제어되는 연결 정보
 - 세션 ID SID
 - 세션리더는 해당 세션에 실행중인 프로세스중 쉘을 일반적으로 칭함
 - 세션 리더 pid는 세션 id와 일반적으로 같음

![image](https://github.com/user-attachments/assets/46388152-87e4-463d-80b5-d0b71c5f16ca)
- sid가 쉘 pid와 일치
- TTY가 단말의 이름을 뜻함

## 프로세스 그룹
- 여러 프로세스를 하나로 묶어서 한꺼번에 관리
- 세션 내부에는 여러 프로세스 그룹이 존재
  - 포그라운드 프로세스 그룹 : 일반적으로 셸의 포그라운드 작업에 대앙흐며 세션당 하나만 존재
  - 백그라운드 프로세스 그룹
  - 쉘이 속해있는 프로세스 그룹
 
![image](https://github.com/user-attachments/assets/be809b3e-0ef4-4b50-ad4a-5cbafc760854)


## 데몬
- 상주하는 프로세스
- 단말의 입출력이 필요없기때문에 단말이 할당되지않음
- 로그인 세션을 종료해도 영향을 받지않도록 독자적인 세션을 가짐
- 데몬을 생성한  프로세스가 데몬 종료 여부를 신경 쓸 필요없이 init가 부모가 됨
- 상주 프로세스를 백그라운드 프로세스로 만들면 안되는 이유
