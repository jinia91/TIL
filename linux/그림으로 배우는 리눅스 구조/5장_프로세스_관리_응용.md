# 빠른 프로세스 작성 처리
## fork() 함수 고속화 copy on write
- fork() 함수 호출시 부모프로세스의 메모리 전체를 복사하는 방식이 아니라, 공유 메모리로 지정하고 쓰기 권한을 없앤 뒤 페이지 테이블만 복사하여 두개의 프로세스가 하나의 물리 주소를 보는 방식으로 복사한다.
- 이후 자식이나 부모중 어느한쪽이 데이터를 갱신하려고 하면 페이지 공유를 해제하고 프로세스마다 전용페이지를 만든다.
  - 1. 쓰기 권한이 없으므로 페이지 폴트 발생
    2. 커널모드에서 커널의 페이지 폴트 핸들러가 동작
    3. 접속한 페이지를 별도의 물리메모리에 복사
    4. 기존 접속한 페이지는 부모의 쓰기권한 부여, 복사한 메모리는 자식의 쓰기권한을 부여

![image](https://github.com/user-attachments/assets/0e8093d6-e237-4907-a99f-bea60e3227c9)

- RSS (Resident Set Size): 이는 프로세스가 현재 사용 중인 실제 메모리의 양

- MAJFL (Major Page Faults): 메이저 페이지 폴트는 필요한 데이터가 메모리에 없어 디스크에서 데이터를 가져와야 할 때 발생

- MINFL (Minor Page Faults): 마이너 페이지 폴트는 필요한 페이지가 메모리에는 없지만 스왑 공간이나 디스크에서 쉽게 가져올 수 있을 때 발생

### 위 테스트로 알수있는점
- 자식 프로세스 생성 직후 메모리사용량은 거의 늘어나지 않음 == 페이지 테이블 할당정도
- 메모리를 접근할 때, used가 100mb 증가된것을 확인할 수 있음
- used는 물리메모리 사용량
- 반대로 rss값이 변화 없는걸 보면 ,rss는 단순히 페이지 테이블의 물리메모리 합계임을 알수 있음
- rss는 물리메모리를 대변할수 없다


## execve() 함수의 고속화: Demand paging
프로세스 새로운 시작시 페이지 테이블만 만들고 실제 물리메모리에 연결을 지연하는 demand paging은 execve() 함수에서도 동작함
- 빈 엔트리만 만들고 실제 엔트리를 조회시 페이지 폴트와 페이지 폴트 핸들러로 물리 메모리에 매핑

# 프로세스 통신
- 프로세스간 통신 기법들

## 공유 메모리
- 프로세스간 공유하는 메모리를 두고 이를 접근하는 방식

## 시그널
- SIGUSR1, SIGUSR2 는 사용자 정의 시그널
- 시그널을 정의해서 프로세스간 통신을 구현할 수 있다
- 하지만 리턴값이 제대로 없기때문에 굉장히 로우단 구현할때나 쓰임

## 파이프
- 리턴값을 받아 사용하는방식 `|`
- 양방향 통신도 가능, 파일을 사용해서 프로세스를 연결하는 것도 가능

## 소켓 
- 프로세스끼리 소켓으로 연결해서 통신 가능
  - 유닉스 도메인 소켓도 존재함
  - 일반적으로는 TCP, UDP{ 소켓을 사용

 # 배타적 제어
 - 동시 접근하면 안되는 공유 데이터에 대해 배타적 제어로 관리
 - 동시성 이슈 핸들링이다
- 결국 락 걸기
- 동시성 핸들링은 따로 정리를 한번 빡쎄게 해보자

# 멀티 프로세스와 멀티스레드
- 멀티스레드의 장점
  - 페이지 테이블 복사가 필요 없어서 생성시간이 짧음
  - 다양한 자원을 동일한 프로세스 내부의 모든 스레드가 공유하므로 메모릴르 비롯한 자원 소비량이 적음
  - 모든 스레드가 메모리를 공유하므로 협조해서 동작하기 쉬움
- 멀티스레드의 단점
  - 하나의 스레드에서 발생한 장애가 모든 스레드에 영향을 줌
  - 스레드 세이프한 고려가 필요
 

  # 커널 스레드와 유저 스레드
## 커널 스레드 
- 커널레벨에서 생성되고 커널이 직접 관리하는 스레드, cpu에서 실제로 실행되는 단위(cpu 스케줄링의 단위)
- 커널레벨에서 프로세스와 스레드는 사실 같은 task stuc
- 단지 생성시점에 공유하는 메모리가 있냐 없냐의 차이
- LWP(lightweight process)로서 프로세스의 스레드들은 pid는 공유하되 lwp 가 고유 아이디로 할당된다


## 유저 스레드 
- 스레드 개념을 프로그래밍 레벨에서 추상화한것. 사용자 단에서 생성 및 관리되는 스레드이며 커널은 해당 스레드를 알지 못한다.
- clone() 시스템콜을 사용하지 않고 스레드 라이브러리 안에서 객체로 생성한 것 사용자 스레드
  - 프로세스에서 해당 스레드를 커널스레드에 매핑해 사용하는 개념
  - 

## jvm 스레딩 모델

### jvm 1.3 이전
- green thread라고 완전히 커널 스레드와 독립된 애플리케이션 레벨의 유저스레드를 만들고 1개의 커널 스레드만 사용하여 1대 다 매핑으로 관리
- 멀티 코어가 되면서 자연스레 사장
- 매니 투 원 모델이라 부름

### 1.3이후 초기 네이티브 스레드 모델
- os 커널의 일부 도움을 받아서 스레드 관리하는 모델

![image](https://github.com/user-attachments/assets/e9c409ad-1693-4726-9571-f33f2a61d3fd)

- solaris 플랫폼 기준 jvm은 many to many mapping 방식을 취함
- 여러 커널 스레드를 네이티브 스레드로서 os 레벨에서 1단계 추상화
- 추상화된 네이티브 스레드를 다시 유저레벨 스레드에 매핑한느 방식

### 현재 jvm
- one to one 매핑 방식으로 동작
- jvm21이후론 one to one to many 방식의 가상 스레드도 도입

