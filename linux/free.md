# free 커맨드시 볼수 있는 정보
<img width="800" alt="스크린샷 2023-05-06 오후 1 49 48" src="https://user-images.githubusercontent.com/85499582/236607783-a62a83e1-1a84-4fee-b213-199109e7360b.png">

- buff : 버퍼 용도로 사용하고 있는 메모리 양, 프로세스가 사용하는 메모리 영역이 아니고 시스템의 성능 향상을 위해서 커널에서 사용하고 있는 영역
- cache: 페이지 캐시라고 불리는 캐시 영역에 있는 메모리 양, I/O 관련 작업을 더 빠르게 진행하기 위해 커널에서 사용하고있는 영역
- available : 사용 가능한 메모리, 실제로 사용되지 않은 메모리와 버퍼 및 캐시로 사용되고 있는 메모리를 합한 값

# buff/cache 자세히 보기
- 커널은 기본적으로 블록 디바이스라고 부르는 디스크로부터 데이터를 읽거나 사용자의 데이터를 디스크에 저장
- 디스크는 매우 느리므로 이를 보완하기위해, 메모리으 ㅣ일부를 디스크 요처에 대한 캐싱영역으로 할당하여 사용
> 즉 한번 읽은 디스크의 내용을 메모리에 저장해 두어, 동일한 내용을 읽고자 하명 디스크로 요청하지 않고 메모리로 요청!

이떄 사용하는 캐싱영역이 buff, chached

## 리눅스 파일 시스템 요약

> 파일이나 자료를 쉽게 발견 및 접근할 수 있도록 보관하는 체제, 다양한 물리 저장장치의 데이터를 일괄되게 관리하기위한 추상 인터페이스

### 목적
- 데이터를 빠르게 읽고 저장할수 있는 단위 블록을 소프트웨어적으로계산
- 분산 저장된 연관 데이터 탐색
- 디스크 조작모음과 같이 디스크 공간을 효율적으로 사용가능케 해줌

### 구성요소
- 부트블록 : 운영체제를 메모리에 올리는 역할을 하는 프로그램이 있는 영역
- 슈퍼블록 : 파일 시스템에 대한 정보를 저장하고 있는 영역
- I-Node 리스트 : I-node를 모아놓은 영역
- 데이터 블록 : data를 저장하고 있는 영역

## buff, chached

![image](https://user-images.githubusercontent.com/85499582/236609090-eb8c857a-8017-4536-b502-71a810b110a2.png)


- page Cache: 파일의 내용을 저장하고 있는 캐시
- buffer Cache: 파일 시스템의 메타정보를 담고 있는 캐시

### 대략적 시나리오를 통해 이해해보자


#### 스프링 애플리케이션이 배포되어 실행된 초기라면

|total|used| free | buff/cached | available|
|-|-|-|-|-|
|4|2|1|1|2|

total(4) = used(2) + free(1) + buff/cache(1)
available은 추정치라 단순 free 의 값으로 연산 불가능


#### 일정 시간이 지난 후

|total|used| free | buff/cached | available|
|-|-|-|-|-|
|4|2|0.x|2|2|

여러가지 I/O 연산이 일어나면서, cached 영역, used 영역이 증가하고 메모리가 가득차기 시작


#### 더 많은시간이 지난후

|total|used| free | buff/cached | available|
|-|-|-|-|-|
|4|3|0.x|1|2|

사용영역이 더 증가하게된다면 캐시영역을 반환하고 이를 사용

이런 과정을 반복하다보면 캐싱영역이 0이 되고, 그럼 swap을 사용하기 시작한다.

# /proc/meminfo?

> free보다 좀더 자세하게 메모리 사용현황 체크하기

<img width="455" alt="image" src="https://user-images.githubusercontent.com/85499582/236615017-a444fd74-4362-4a6c-8601-3c988debb4f0.png">

- swapCached: swap으로 빠진 메모리 영역중 다시 메모리로 돌아온 영역을 의미
  - 일시적으로 swap이 발생했다가 가용공간이 생겨 다시 물리메모리를 사용하더라도, swap에 들어갔던 데이터는 삭제되지 않고, 이후 다시 swap이 발생할때, 해당 영역을 그대로 다시 사용
  - 위 논리라면 한번 swap에 들어간 영역은 이후 메모리가 가득찰시 가장 최우선으로 물리메모리상에서 날라가는듯?

- active(anon) :  프로세스에서 동적으로 할당된 메모리 중 이름이 없는 영역으로 비교적 최근 참조되어 swap영역으로 이동되지 않을 메모리영역
- inactive(anon) : 비교적 참조된지 오래되어 swap영역으로 이동될 수 있는 메모리 영역
  - pagination을 통해 가장 참조가 오래된 영역부터 swap이 일어남(LRU)

- active(file) : 커널 I/O 향상을 위해 사용하는 영역, buff/cached 가 여기에 해당하며 그중 비교적 최근까지 참조되어 swap하지 않을부분
- Inactive(file) : I/O 성능 향상을 위해 커널이 캐시 목적으로 사용중 swap 우선순위가 높은 부분
- Dirty: 지연쓰기 작업시 잠시쓰는 버퍼


여기서 active / inactive는 LRU 알고리즘으로 구분될텐데 계산은 어디서할까?
> 리눅스 커널 소스상
> fs/proc/meminfo.c

기본적으로 active 가 inactive로 가는 시점은 메모리 부족상황이 와서 해제해야할 메모리를 찾아야할때!
이전까진 모두 active에 있다.

## slab?
> 커널이 사용하고 있는 영역

- slab: 커널이 사용
- SReclaimable: Slab 영역중 재사용 될수 있는 영역. 캐시 용도로 사용하는 메모리들이 주로 여기 포함, 메모리 부족이 일어나면 해제되어 프로세스에 할당될 수 있는 영역
- SUnreclaim : Slab 영역 중 재사용될 수 없는 영역. 커널이 현재 사용중인 영역이며 해제해서 다른 용도로 사용할 수 없다

### 왜 slab으로 관리?

- 커널도 메모리 할당이 필요
- 버디시스템은 기본적으로 4kb 단위로 메모리 할당
- 하지만 커널의 대부분의 다비이스 드라이버등은 이정도 크기의 메모리가 필요하지 않는경우가 많음
- 따라서 버디시스템에서 벗어나 독자적으로 메모리를 관리할 필요가 있음

<img width="882" alt="image" src="https://user-images.githubusercontent.com/85499582/236616134-cb7edb7f-e8a2-4774-880f-9ec852a3b176.png">

> slabtop 을 통해 slab 이 어떻게 할당되어있는지 확인가능
할당된 사이즈를 보면 1kb 미만이 많다!



