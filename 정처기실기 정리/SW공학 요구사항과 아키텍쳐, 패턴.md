---


---

<h2 id="소프트웨어-개발-방법론">소프트웨어 개발 방법론</h2>
<h3 id="소프트웨어-생명주기-모델-개념">소프트웨어 생명주기 모델 개념</h3>
<p>시스템의 요구분석부터 유지보수까지 전 공정을 체계화한 절차!<br>
개발부터 운용과 유지보수를 거쳐 생애를 마칠 때까지 어떠한 순서를 밟는지에 대한 작업 프로세스를 모델화한 것</p>
<ul>
<li>모델 프로세스
<ul>
<li>요구사항 분석</li>
<li>설계</li>
<li>구현</li>
<li>테스트</li>
<li>유지보수</li>
</ul>
</li>
</ul>
<h3 id="소프트웨어-생명주기-모델-종류">소프트웨어 생명주기 모델 종류</h3>
<ul>
<li>
<p>폭포수 모델<br>
각 단계를 확실히 마무리 지은 후에 다음 단계로 넘어가는 가장 오래된 방식<br>
선형 순차적, 고전적 생명주기<br>
성공사례많고 단계별 정의와 산출물이 명확</p>
</li>
<li>
<p>프로토 타이핑 모델<br>
고객이 요구하는 주요기능 프로토타입으로 구현하여, 고객의 피드백을 반영하여 소프트웨어를 만들어가는 모델</p>
</li>
<li>
<p>나선형 모델<br>
시스템 개발시 위험을 최소화하기 위해 점진적으로 완벽한 시스템으로 개발해나가는 모델<br>
계획 및 정의 - 위험 분석 - 개발 - 고객평가</p>
</li>
<li>
<p>반복적 모델<br>
구축대상을 나누어 병렬적으로(증분방식) 개발 후 통합하거나, 반복적으로 개발하여 점증 완성시키는 모델</p>
</li>
</ul>
<h3 id="소프트웨어-개발-방법론-1">소프트웨어 개발 방법론</h3>
<ul>
<li>
<h4 id="구조적-방법론">구조적 방법론</h4>
<p>전체 시스템을 기능에 따라 나누어 개발, 분할정복접근방식 하향식 방법론</p>
</li>
<li>
<h4 id="정보공학-방법론">정보공학 방법론</h4>
<p>정보시스템 개발에 필요한 관리 절차와 작업 기법을 체계화한 방법론<br>
개발주기를 이용해 대형 프로젝트를 수행하는 체계적인 방법론</p>
</li>
<li>
<h4 id="객체지향-방법론ood">객체지향 방법론(OOD)</h4>
<p>객체라는 기본 단위로 시스템을 분석 및 설계하는 방법론</p>
</li>
<li>
<h4 id="컴포넌트-기반-방법론cbd">컴포넌트 기반 방법론(CBD)</h4>
<p>소프트웨어를 구성하는 컴포넌트를 조립해서 하나의 새로운 응용프로그램을 작성하는 방법론<br>
개발기간 단축으로 인한 생산성 향상<br>
새로운 기능 추가 쉬움(확장성)<br>
소프트웨어 재사용이 가능</p>
</li>
<li>
<h4 id="애자일-방법론">애자일 방법론</h4>
<p>절차보다는 사람이 중심이 되어 변화에 유연하고 신속하게 적응하면서 효율적으로 시스템을 개발할 수 있는 신속 적응적 경량 개발방법론</p>
</li>
<li>
<h4 id="제품계열-방법론">제품계열 방법론</h4>
<p>특정 제품에 적용하고 싶은 공통된 기능을 정의하여 개발하는 방법론<br>
임베디드 소프트웨어 작성 영역에서 유용</p>
</li>
</ul>
<h3 id="애자일">애자일</h3>
<p>개념 : 절차보다는 <strong>사람이 중심</strong>이 되어 변화에 유연하고 신속하게 적응하면서 효율적으로 시스템을 개발할 수 있는 신속 적응적 경량 개발방법론</p>
<p>개발 기간이 짧고 신속하며 폭포수 모형에 대비되는 방법론으로 개발과 함께 즉시 피드백을 받아서 유동적으로 개발할 수 있다.</p>
<h4 id="xpextreme-programming">XP(eXtreme Programming)</h4>
<ul>
<li>
<p>의사소통 개선과 즉각적 피드백으로 소프트웨어 품질을 높이기 위한 방법론</p>
</li>
<li>
<p>1~3주의 반복 개발주기</p>
</li>
<li>
<p>5가지 가치와 12개의 실천항목이 존재</p>
</li>
<li>
<p>xp의 다섯가지 가치</p>
<ul>
<li>용기, 단순성, 의사소통, 피드백, 존중</li>
</ul>
</li>
<li>
<p>12가지의 기본 원리</p>
<ul>
<li>짝 프로그래밍 : 개발자 둘이서 짝으로 코딩하는 원리</li>
<li>공동 코드 소유 : 시스템에 있는 코드는 누구든지 언제라도 수정 가능하다는 원리</li>
<li>지속적인 통합(CI) : 매일 여러번씩 소프트웨어를 통합하고 빌드해야한다는 원리</li>
<li>계획 세우기</li>
<li>작은 릴리즈 : 작은 시스템을 먼저 만들고 짧은 단위로 업데이트 한다는 원리</li>
<li>메타포어 : 공통적인 이름체계와 시스템 서술서를 통해 고객과 개발자간의 의사소통을 원활하게 한다는 원리</li>
<li>간단한 디자인 : 현재의 요구사항에 적합한 가장 단순한 시스템을 설계한다는 원리</li>
<li>TDD : 테스트코드를 먼저 작성하고 이 테스트를 통과할 실제 프로그램의 코드를 작성한다는 원리</li>
<li>리팩토링 : 프로그램의 기능을 바꾸지 않으면서 중복제거, 단순화 등을 위해 시스템 재구성한다는 원리</li>
<li>40시간 작업</li>
<li>고객상주: 고객을 프로젝트에 사웆</li>
<li>코드 표준 : 효과적인 공동작업을 위해서는 모든 코드에 대한 코딩 표준을 정의해야한다는 원리</li>
</ul>
</li>
</ul>
<h4 id="스크럼">스크럼</h4>
<p>매일 정해진 시간, 장소에서 짧은 시간의 개발을 하는 팀을 위한 프로젝트 관리 중심 방법론</p>
<ul>
<li>백로그 : 제품과 프로젝트에 대한 요구사항</li>
<li>스프린트 : 2~4주의 짧은 개발 기간으로 반복적 수행으로 개발품질 향상</li>
<li>스크럼 미팅 : 매일 15부정도 미팅으로 TO-DO List 계획 수립</li>
<li>스크럼 마스터 : 프로젝트 리더</li>
<li>스프린트 회고 : 스프린트 주기를 되돌아보며 정해놓은 규칙 준수 여부, 개선점등을 확인 및 기록</li>
<li>번다운 차트 : 남아있는 백로그 대비 시간을 그래픽적으로 표현한 차트<br>
백로그는 보통 수직축에 위치하며 시간은 수평축에 위치</li>
</ul>
<h4 id="린">린</h4>
<p>도요타의 린 시스템 품질기법을 소프트웨어 개발 프로세스에 적용해서 낭비 요소를 제거하여 품질을 향상시킨 방법론<br>
JIT, 칸반 보드 사용</p>
<h3 id="전통적-방법론과의-비교">전통적 방법론과의 비교</h3>

<table>
<thead>
<tr>
<th>구분</th>
<th>전통적</th>
<th>애자일</th>
</tr>
</thead>
<tbody>
<tr>
<td>계획수립</td>
<td>확정적범위설정</td>
<td>유동적범위설정</td>
</tr>
<tr>
<td>업무수행</td>
<td>관리자주도,개인단위</td>
<td>팀단위</td>
</tr>
<tr>
<td>개발/검증</td>
<td>분석-설계-구현-테스트</td>
<td>반복주기단위(개발-설계-테스트)</td>
</tr>
<tr>
<td>팀단위</td>
<td>경쟁</td>
<td>몰입,팀평가</td>
</tr>
<tr>
<td>문서화</td>
<td>상세한 문서화강조</td>
<td>문서화보다는 코드</td>
</tr>
<tr>
<td>성공요소</td>
<td>계획준수</td>
<td>고객가치전달</td>
</tr>
<tr>
<td>유형</td>
<td>폭포수,프로토타입,나선형</td>
<td>xp,스크럼,칸반,린,TDD,FDD</td>
</tr>
</tbody>
</table><h2 id="비용산정-일정관리-모형">비용산정, 일정관리 모형</h2>
<ul>
<li>하향식 산정방법
<ul>
<li>전문가 판단</li>
<li>델파이 기법 : 전문가의 경험적 지식을 통한 문제해결 및 미래예측을 위한 기법</li>
</ul>
</li>
<li>상향식 산정 방법
<ul>
<li>코드라인수(LOC)</li>
<li>Man Month</li>
<li>COCOMO 모형</li>
<li>푸트남모형</li>
<li>기능점수 모형</li>
</ul>
</li>
</ul>
<h3 id="loc">LoC</h3>
<p>각 기능의 원시 코드 라인 수의 낙관치, 중간치, 비관치를 측정하여 예측치를 구하고 이를 이용하여 비용을 산정하는 방식<br>
측정이 쉽고 이해하기 쉬워 많이 사용됨</p>
<p>(낙+중*4+비)/6</p>
<h3 id="man-month단위">Man Month(단위)</h3>
<p>한사람이 1개월동안 할 수 있는 일의 양을 기준으로 프로젝트 비용을 산정하는 방식</p>
<p>ex) 총 코드수 3만개, 개발자 평균 월간 생산 코드 300줄<br>
= Man Month 는 100개월</p>
<p>LOC/ 프로그래머의 월간 생산성 = Man Month<br>
프로젝트 기간 = Man Month / 프로젝트 인력</p>
<h3 id="cocomo-모형">COCOMO 모형</h3>
<p>보헴이 제안한 모형, 프로그램 규모에 따라 비용을 산정하는 방식</p>
<h3 id="푸트남-모형">푸트남 모형</h3>
<p>소프트웨어 개발주기의 단계별로 요구할 인력의 분포를 가정하는 방식<br>
생명주기 예측 모형<br>
시간에 따른 함수로 표현되는 노력분포도 기초</p>
<h3 id="기능-점수-모형">기능 점수 모형</h3>
<p>요구 기능을 증가시키는 인자별로 가중치 부여, 요인별 가중치를 합산하여 총 기능의 점수를 계산하여 비용산정방식</p>
<h3 id="일정관리-모델">일정관리 모델</h3>
<ul>
<li>CPM(주 공정법): 가장 오래걸리는 경로로 계산할것</li>
<li>PERT : 일의 순서를 계획적으로 정리하기 위한 수렴기법, 3점추정</li>
<li>중요연쇄프로젝트관리</li>
</ul>
<h2 id="시스템-분석">시스템 분석</h2>
<h3 id="소프트웨어-아키텍쳐-41-뷰">소프트웨어 아키텍쳐 4+1 뷰</h3>
<p>고객의 요구사항을 정리해놓은 시나리오(유스케이스)를 4개의 관점으로 바라보는 소프트웨어적인 접근방법<br>
4개의 분리돈 구조로 구성되는 아키텍쳐 개념을 제시하고 이들 4개 구조가 서로 충돌되지 않는지, 시스템의 요구사항을 충족시키는지를 증명하기 위해 체크 방법으로 유스케이스를 사용</p>
<ul>
<li>유스케이스 + 논리, 구현, 프로세스, 배포</li>
</ul>
<h3 id="소프트웨어-아키텍쳐-패턴">소프트웨어 아키텍쳐 패턴</h3>
<h4 id="계층화-패턴layer-">계층화 패턴(layer) :</h4>
<p>시스템을 계층으로 구분하여 구성<br>
각 하위 모듈들은 특정한 수준을 ㅗ추상화를 제공하고, 각 계층은 다음 상위계층에 서비스를 제공</p>
<h4 id="클라이언트---서버-패턴">클라이언트 - 서버 패턴</h4>
<p>하나의 서버와 다수의 클라이언트로 구성된 패턴</p>
<h4 id="파이프-필터-패턴">파이프 필터 패턴</h4>
<p>데이터 스트림을 생성하고 처리하느 시스템에서 사용가능한 패턴<br>
필터패턴은서브시스템이 입력 데이터를 받아 처리하고 결과를 다음 서브 시스템으로 넘겨주는 과정을 반복<br>
필터컴포넌트는 재사용성이 좋고 추가하기 쉽기때문에 확장이 용이</p>
<h4 id="브로커-패턴">브로커 패턴</h4>
<p>rpc, 분산시스템에서 주로 사용<br>
클라이언트와 서버 사이에 중간 매개체를 둬서 다기종 클라이언트의 요구를 모두 소화하기 위해 사용함<br>
표준화되지 않은 클라이언트들의 요청을 브로커가 서버에 맞게 변환 혹은 반대상황</p>
<h4 id="mvc-패턴">MVC 패턴</h4>
<p>대화형 애플리케이션을 모델, 뷰, 컨트롤러</p>
<ul>
<li>모델 : 핵심 기능과 데이터보관</li>
<li>뷰 : 사용자에게 정보 표시</li>
<li>컨트롤러 : 사용자로부터 요청을 입력받아 처리</li>
</ul>
<h2 id="디자인-패턴">디자인 패턴</h2>
<p>소프트웨어 설계에서 공통으로 발생하는 문제에 대해 자주 쓰이는 설계방법 정리</p>
<h4 id="디자인-패턴-유형">디자인 패턴 유형</h4>
<p>목적에 따라</p>
<ul>
<li>
<p>생성</p>
</li>
<li>
<p>구조</p>
</li>
<li>
<p>행위</p>
</li>
</ul>
<p>범위에따라</p>
<ul>
<li>클래스간 관련성(상속관계) - 컴다일 타임</li>
<li>객체간 관련성 - 런타임 타임</li>
</ul>
<hr>
<h3 id="생성패턴">생성패턴</h3>
<h4 id="builder">Builder</h4>
<ol>
<li>
<p>복잡한 상태를 보유한 객체를 만들때, 그 객체의 생성담당 객체를 따로 설계하는것(팩토리 메소드 패턴도 동일)</p>
</li>
<li>
<p>이때 생성담당객체(builder)는 인터페이스와 구현으로 나누어 동일한 생성 절차로 서로 다른 객체를 만들수 있도록 한다.(팩토리 메소드 패턴도 동일)</p>
</li>
<li>
<p>팩토리 메소드와 주요 차이점은 Builder패턴은 setter을 열어두고 모든 파라미터에대해 래핑을 하는 방식이라는것<br>
=&gt; 래핑된 빌더 객체에 세터로 파라미터를 주입하면 주입된 파라미터를 생성자로 정렬시켜서 해당 객체를 반환하는방식으로 이해하자</p>
</li>
</ol>
<h4 id="prototype">Prototype</h4>
<p>추상팩토리(Abstract Factory) 패턴과는 반대<br>
원형 객체가 존재하며 해당 객체에 clone() 메소드를 만들어<br>
원형 객체로부터 복제된 객체를 얻는 방식</p>
<h4 id="factory-method">Factory Method</h4>
<p>빌더 패턴과 유사하지만 팩토리 메소드 패턴은 생성자를 래핑하는 방식으로<br>
팩토리 메소드를 통해 반환 객체의 속성을 알지 못한다.</p>
<h4 id="abstract-factory">Abstract Factory</h4>
<p>추상 팩토리 패턴은 구체적인 자식클래스들에 의존하지 않고 연관되거나 의존적인 객체들을 묶어서 해당 객체들을 한번에 만드는 인터페이스(추상 팩토리)를 제공하는 패턴.</p>
<p>빌더는 커스텀 피자를 만드는 방식(생성자 파라미터를 빌더의 세터메소드로 래핑해서 api세터를 통해 생성됨!)<br>
팩토리 메소드는 핸드폰 부품을 만드는방식(메모리에 삼성메모리, 엘지메모리가 있을때 삼성메모리의 생성자 패러미터들을 다 정해놓고 삼성메모리 제조 메소드만 제공하여 객체를 생성하는, 생성자 래핑 방식)<br>
추상 팩토리는  핸드폰을 만드는 방식(삼성 핸드폰에 들어갈 삼성 메모리, 삼성 디스플레이 삼성 메인보드 등등을 한번에 만드는 Factory Of Factory 를 만들어 해당 FOF에 메시지를 전달하는 방식 연관된 객체들의 팩토리를 묶어 상위 팩토리를 만든다고 이해하면됨)</p>
<h4 id="singleton">Singleton</h4>
<p>전역변수 사용하지 않고 객체가 하나만 존재하는것을 보장하는 패턴. 생성된 객체는 어디에서든 참조할수 있음</p>
<h3 id="구조-패턴">구조 패턴</h3>
<h4 id="bridge">Bridge</h4>
<ol>
<li>객체의 기능부와 구현부를 분리한뒤 구현부를 다시 추상계층과 구현계층으로 분리한다.</li>
<li>기능계층에 구현의 추상계층(브리지)을 주입하는 구조를 통해</li>
<li>새로운 기능이 추가되더라도 인터페이스나 구현부를 수정하지 않고 새로운 인터페이스+ 구현부만으로 기능 확장이 가능하게 하는 패턴</li>
</ol>
<p>ex)</p>
<ul>
<li>배달 서비스 기능부 (IDeliveryService)</li>
<li>배달 서비스 추가기능+ (PlusDeliveryService extends IDeliveryService)</li>
<li>배달 서비스 추상구현 인터페이스 (IDeliveryServiceImpl) - 브리지 역할</li>
<li>쿠팡 배달 서비스 구현체 (CoupangDeliveryServiceImpl implements DelivceryServiceImpl)</li>
</ul>
<h4 id="decorator">Decorator</h4>
<p>상속의 대안으로 기능 추가하는 방식 책임 추가하기!<br>
인터페이스는 유지하되 기능이 추가되는 경우 인터페이스와 구현체 사이에 데코레이터 객체를 삽입해서 기능을 더하는 방식</p>
<pre><code>ex ) new IService(
		new CoupangDeliveryServiceDecorator(
			new DeliveryService()))
</code></pre>
<h4 id="facade">Facade</h4>
<p>복잡한 시스템에 대하여 단순한 인터페이스를 제공, 사용자와 시스템간 또는 여타 시스템과의 결합도를 낮추어 시스템 구조에 대한 파악을 쉽게 하는 패턴 쉽고 간편한 통합 인터페이스 제공이 핵심<br>
여러 객체들의 메소드들을 통합해서 하나의 메소드로 수행할수 있게해주는 통합 인터페이스 객체를 만든다고 보면 됨</p>
<h4 id="flyweight">Flyweight</h4>
<p>다수의 객체를 만들게 될경우 공통된 본질적 속성을 클래스화하여 공유하게함으로써 메모리 절감을 하는 패턴<br>
클래스에 static 컬렉션 속성을 넣고 여기에 공통 속성들을 저장한뒤 객체를 생성할때 필요속성을 끄집어내 장착시켜 생성하는것인가? 개념이 어려움,</p>
<h4 id="proxy">Proxy</h4>
<p>필요 객체에 접근하기 이전에 대리객체를 사용하여 필요 객체의 생성시점을 연기시키는 패턴<br>
껍데기인 대리객체만 미리 만들어놓고 실제 서비스를 이용할때 실제 객체를 생성하여 메모리 할당이 일어나게 할 수 있으므로 메모리 절약이 가능하고 실제 객체를 한번더 래핑하기때문에 정보 은닉 역할도 가능!</p>
<h4 id="composite">Composite</h4>
<p>객체들의 관계를 트리구조로 구성하여 부분 전체를 표현, 자료구조를 나타낼때 사용하는 패턴으로보면 됨</p>
<h4 id="adapter">Adapter</h4>
<p>인터페이스가 호환되지않는 클래스들을 함께 이용할 수 있도록 타 클래스의 인터페이스를 기존 인터페이스에 덧씌우는 패턴 스프링의 핸들러 어댑터같은걸 생각하자</p>
<h3 id="행위패턴">행위패턴</h3>
<h4 id="mediator">Mediator</h4>
<p>객체수가 많아질 경우 결합도 완화를 위해 중간 통신 매개객체를 사용하여 의존성을 줄이는 패턴</p>
<h4 id="interpreter">Interpreter</h4>
<p>언어의 다양한 해석, 구체적으로 구문을 나누고  그 분리된 구문의 해석을 맡는 클래스를 각각 작성하여 여러 형태으 언어 구문을 해석할 수 있게 만드는 디자인 패턴</p>
<h4 id="iterator">Iterator</h4>
<p>컬렉션 구현 방법을 노출시키지 않으면서도 그 집합체안에 들어있는 모든 항목에 접근하는법을 제공하는 디자인 패턴</p>
<h4 id="template-method">Template Method</h4>
<p>어떤 작업을 하는 일부분을 서브클래스로 캡슐화해 전체 일을 수행하는 구조는 바꾸지 않으면서 특정 단계에서 수행하는 내역을 바꾸는 패턴<br>
대부분의 생성 패턴들이 템플릿 메소드 패턴을 기본적으로 포함함!</p>
<h4 id="observer">Observer</h4>
<p>한 객체의 상태가 바뀌면 그 객체에 의존하는 다른 객체들에 연락이 가고 자동으로 내용이 갱신되는 방법<br>
일대 다의 의존성, 객체의 상태 변화에 따라 다른객체 상태도 연동</p>
<h4 id="state">State</h4>
<p>객체 상태를 캡슐화함으로써 그것을 참조하게 하는 방식<br>
상태에 따라 다르게 처리할 수 있도록 행위내용을 변경한다.</p>
<p>상태를 주입하여 주입된 상태에 따라 행위가 바뀌게 할 수 있음!</p>
<p>바꾸는 로직은 근데 어디서 구현?</p>
<h4 id="visitor">Visitor</h4>
<p>각 클래스 데이터 구조로부터 처리기능을 분리하여 별도의 클래스로 만든뒤, 해당 클래스의 메서드가 각 클래스를 돌아다니며 특정 작업을 수행하도록 만드는 패턴<br>
객체구조변경없이 기능만 따로 추가하거나 확장에 유용함</p>
<h4 id="commnad">Commnad</h4>
<p>실핼될 기능을 캡슐화한뒤 여러 기능들을 하나의 명령으로 수행할수 있도록 추상화한 커맨드 클래스와  커맨드 메서드를 만드는 패턴</p>
<h4 id="strategy">Strategy</h4>
<p>알고리즘군을 묶어서 추상클래스로 만든뒤 각각 알고리즘을 별도의 클래스로 만들어 캡슐화하고 필요할때 교환하여 사용할 수 있게 하는 패턴<br>
동적으로 행위를 자유롭게 변환하는방식</p>
<h4 id="memento">Memento</h4>
<p>클래스 설계 관점에서 객체의 정보를 저장할 필요가 있을때 적용하는 디자인 패턴 - undo 기능 개발시 주로 사용!</p>
<h4 id="chain-of-responsibility">Chain of Responsibility</h4>
<p>한 요청을 두개이상의 객체에서 처리할때 사용?</p>
<h2 id="요구사항-확인">요구사항 확인</h2>
<h3 id="요구공학의-개념">요구공학의 개념</h3>
<p>요구공학은 사용자의 요구가 반영된 시스템을 개발하기 위하여 사용자 요구사항에 대한 도출, 분석, 명세, 확인 및 검증하는 구조화된 활동!</p>
<p>이해관계자 사이에 효과적인 의사소통 수단을 제공하고 시스템 개발의 요구사항에 대한 공통된 이해를 설정</p>
<h3 id="요구사항-분류">요구사항 분류</h3>
<ul>
<li>기능적 요구사항<br>
시스템이 제공하는 기능, 서비스에대한 요구사항</li>
<li>비기능적 요구사항<br>
시스템이 수행하는 기능 이외의 사항, 시스템 구축에 대한 제약사항에 관한 요구사항 주로 성능이나 가동성 등등</li>
</ul>
<h3 id="요구공학-프로세스">요구공학 프로세스</h3>
<p>도출 - 분석 - 명세 -확인 및 검증</p>

